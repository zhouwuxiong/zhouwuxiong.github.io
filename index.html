<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.146.0"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PaperMod</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://zhouwuxiong.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zhouwuxiong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhouwuxiong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhouwuxiong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhouwuxiong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhouwuxiong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://zhouwuxiong.github.io/index.xml">
<link rel="alternate" type="application/json" href="https://zhouwuxiong.github.io/index.json">
<link rel="alternate" hreflang="en" href="https://zhouwuxiong.github.io/">
<link rel="alternate" hreflang="fr" href="https://zhouwuxiong.github.io/fr/">
<link rel="alternate" hreflang="fa" href="https://zhouwuxiong.github.io/fa/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

>
<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
<meta property="og:url" content="https://zhouwuxiong.github.io/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="PaperMod">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PaperMod">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "PaperMod",
  "url": "https://zhouwuxiong.github.io/",
  "description": "",
  "logo": "https://zhouwuxiong.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhouwuxiong.github.io/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fr/" title="French"
                            aria-label=":fr:">Fr</a>
                    </li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhouwuxiong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="first-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ORB_SLAM2 核心代码解析
    </h2>
  </header>
  <div class="entry-content">
    <p>1 单目初始化 ORB_SLAM 的地图初始化主要分为 5 个过程。 第一步时根据特征点匹配选择匹配数量足够多的两帧图像作为初始图像， 第二步根据匹配特征点进行多轮 ransac 迭代，通过 8 点法求解基础矩阵和单应矩阵， 第三步利用初始位姿三角化地图点，并过滤一些不好的地图点主要包括 (距离太远的点，因为距离太远的点深度估计不准确， 重投影误差太大的点等等)。 第四步进行R，t的选取，做这一步的原因是由于单目初始化求的是一个相对位姿关系，没有一个固定的坐标系，所以其旋转、平移的正方向不确定，因此求解结果会存在多种运动组合。对于基础矩阵会有四种解，但是对于 H 矩阵会存在 8中解，因为单应矩阵是利用平面法向量做映射，它引入了平法向量的正负不确定性。除此之外基础矩阵还需要做平移量大小的判断，因为如果两帧之间的平移量太小，会导致深度计算的不准确，像素的误差会被无限放大到深度上，而且像素坐标是有分辨率极限的不是连续的，所以深度误差必定存在。 第五步构建地图点与之间的链接关系，并使用场景中值深度进行尺度归一化 第六步进行全局 BA 优化，优化完之后根据地图中地图点的深度中值做尺度归一化
Tips1 由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。
Tips2 F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。
2 回环检测 2.1 回环候选帧选取 ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。
图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。 组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。 Step 1 : 相似图像检测 ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。
ORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix KeyFrameDatabase::DetectLoopCandidates
Step 2 : 组连续检测 组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示： ...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to ORB_SLAM2 核心代码解析" href="https://zhouwuxiong.github.io/posts/orb_slam2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ORB_SLAM3 核心代码解析
    </h2>
  </header>
  <div class="entry-content">
    <p>1 VIO 联合初始化 视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。
在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合 2 Step1 单目初始化 MonocularInitialization 单目初始化在 Tracking 中进行
3 Step2 imu 初始化 InitializeIMU() imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 InitializeIMU() ，imu 初始化主要分为4各阶段，前三个阶段都使用InitializeIMU 进行图优化。
为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。
第一次阶段的执行 条件是(关键帧数量&gt;10 并且距离初始关键帧的时间&gt;1s) , InitializeIMU 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化InertialOptimization。
第二和和第三界阶段使用同样调用 InitializeIMU() 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 InitializeIMU 进行初始化，而不是向第一阶段一样只调用一次。
第四阶段为重力方向和尺度精修ScaleRefinement，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。
3.1 InertialOptimization 在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 InertialOptimization 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。 ...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to ORB_SLAM3 核心代码解析" href="https://zhouwuxiong.github.io/posts/orb_slam3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">SLAM 中的基础数学知识
    </h2>
  </header>
  <div class="entry-content">
    <p>1 旋转的表示 1.1 旋转向量 1.2 旋转矩阵 旋转矩阵有且只有一个实数特征值1； 不考虑单位矩阵，旋转矩阵的实数特征值对应的特征向量即是axis-angle表达式的旋转轴，旋转矩阵的迹与旋转角度相关。 1.3 四元数 球面线性插值（Spherical linear interpolation，slerp) ![[1-SLAM 中的基础数学知识.png]] $$ Slerp(p,q,t) = \frac{\sin[(1-t)\theta] &#43; \sin(t \theta q)}{\sin(\theta)} $$ 1.4 旋转表示之间的相互转换 四元数转旋转向量 $$ \begin{cases}{l} \theta = 2\arccos s \\ [n_x,n_y,n_z]^T = \frac{v^T}{\sin{\frac{\theta}{2}}} \end{cases} $$
旋转$\theta\boldsymbol{n}$向量转四元数 $$ \boldsymbol{q} = [\cos \frac{\theta}{2},\boldsymbol{n} \sin \frac{\theta}{2}] \tag{2} $$
旋转矩阵转旋转向量 $$ \begin{cases} \theta = \arccos(\frac{tr(\boldsymbol{R})-1}{2}) \\[1ex] n = Rn, \quad \text{轴n是R特征值为1的单位特征向量} \end{cases} \tag{3} $$
旋转向量$\boldsymbol\omega$转旋转矩阵（罗德里格斯公式） $$ \boldsymbol{R} = \cos\theta \boldsymbol{I} &#43; (1- \cos\theta ) \boldsymbol {n} \boldsymbol {n}^T &#43; \sin\theta \boldsymbol {n}^{\wedge} = exp{(\boldsymbol{\omega^{\wedge}})} \tag{4} $$ 旋转向量转旋转矩阵本质就是对应李代数的指数映射，李代数的指数映射将旋转向量映射为反对称矩阵
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to SLAM 中的基础数学知识" href="https://zhouwuxiong.github.io/posts/slam-%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图像匹配
    </h2>
  </header>
  <div class="entry-content">
    <p>1 BoW ORB_SLAM 使用 BoW 进行相似图像检索，在重定位、回环检测、参考关键帧跟踪过程中都有用到。BoW 是一种 K 叉树形式的分类树，在构造 K 叉树时，根据特征描述的相似性作为距离度量进行聚类，树的叶子节点被计为单词，每个单词使用特征点的聚类中心表示。在进行特征匹配时，根据特征点是否落在同一个叶子节点判断是否对应同一个单词，同时可以得到一个相似度得分。一般在进行图像特征匹配时会根据公共单词数量和最小的相似度得分判断图像之间的相似性。 1.1 TF-IDF TF（Term Frequency），指在单帧中某个单词的频次，频次高，权重大 IDF（Inverse Document Frequency），某个单词在词典中出现的频次，频次越低，则辨识度越高，相应权重 IDF 越大 最终 BoW 的权重是 TF*IDF ，每个单词都有自己的权重。
1.2 正向索引 再计算BoW时，每帧图像会记录一个正向索引表，记录在kd树某一层，命中的节点集合，以及节点中的特征点，用于加速两帧图像之间的特征点匹配。
1.3 逆向索引 orb-slam 中维护了一个关键帧数据库，其中有一个单词的逆向索引表，其记录了包含这个单词的关键帧和权重，用于快速查找匹配关键帧。
1.4 相似性对量 L1 ，各维度的差值的绝对值求和 余弦相似度 ，向量夹角 1.5 levelsup ORB_SLAM 在对图像生成词向量时，会根据 levelsup 记录图像中的单词落在了某层的哪些分支，这样在进行单词匹配时，只需要查找对应分支而不是从根节点开始查找，提高查找效率。 Reference: 基于词袋模型的图像匹配 - Line’s Blog
Appendix:
/* * @brief 通过词袋，对关键帧的特征点进行跟踪，该函数用于闭环检测时两个关键帧间的特征点匹配 * @details 通过bow对pKF和F中的特征点进行快速匹配（不属于同一node的特征点直接跳过匹配） * 对属于同一node的特征点通过描述子距离进行匹配 * 通过距离阈值、比例阈值和角度投票进行剔除误匹配 * @param pKF1 KeyFrame1 * @param pKF2 KeyFrame2 * @param vpMatches12 pKF2中与pKF1匹配的MapPoint，vpMatches12[i]表示匹配的地图点，null表示没有匹配，i表示匹配的pKF1 特征点索引 * @return 成功匹配的数量 */ int ORBmatcher::SearchByBoW(KeyFrame *pKF1, KeyFrame *pKF2, vector&lt;MapPoint *&gt; &amp;vpMatches12) { // Step 1 分别取出两个关键帧的特征点、BoW 向量、地图点、描述子 const vector&lt;cv::KeyPoint&gt; &amp;vKeysUn1 = pKF1-&gt;mvKeysUn; const DBoW2::FeatureVector &amp;vFeatVec1 = pKF1-&gt;mFeatVec; const vector&lt;MapPoint*&gt; vpMapPoints1 = pKF1-&gt;GetMapPointMatches(); const cv::Mat &amp;Descriptors1 = pKF1-&gt;mDescriptors; const vector&lt;cv::KeyPoint&gt; &amp;vKeysUn2 = pKF2-&gt;mvKeysUn; const DBoW2::FeatureVector &amp;vFeatVec2 = pKF2-&gt;mFeatVec; const vector&lt;MapPoint*&gt; vpMapPoints2 = pKF2-&gt;GetMapPointMatches(); const cv::Mat &amp;Descriptors2 = pKF2-&gt;mDescriptors; // 保存匹配结果 vpMatches12 = vector&lt;MapPoint*&gt;(vpMapPoints1.size(),static_cast&lt;MapPoint*&gt;(NULL)); vector&lt;bool&gt; vbMatched2(vpMapPoints2.size(),false); // Step 2 构建旋转直方图，HISTO_LENGTH = 30 vector&lt;int&gt; rotHist[HISTO_LENGTH]; for(int i=0;i&lt;HISTO_LENGTH;i&#43;&#43;) rotHist[i].reserve(500); //! 原作者代码是 const float factor = 1.0f/HISTO_LENGTH; 是错误的，更改为下面代码 const float factor = HISTO_LENGTH/360.0f; int nmatches = 0; DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin(); DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin(); DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end(); DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end(); while(f1it != f1end &amp;&amp; f2it != f2end) { // Step 3 开始遍历，分别取出属于同一node的特征点(只有属于同一node，才有可能是匹配点) if(f1it-&gt;first == f2it-&gt;first) { // 遍历KF中属于该node的特征点 for(size_t i1=0, iend1=f1it-&gt;second.size(); i1&lt;iend1; i1&#43;&#43;) { const size_t idx1 = f1it-&gt;second[i1]; MapPoint* pMP1 = vpMapPoints1[idx1]; if(!pMP1) continue; if(pMP1-&gt;isBad()) continue; const cv::Mat &amp;d1 = Descriptors1.row(idx1); int bestDist1=256; int bestIdx2 =-1 ; int bestDist2=256; // Step 4 遍历KF2中属于该node的特征点，找到了最优及次优匹配点 for(size_t i2=0, iend2=f2it-&gt;second.size(); i2&lt;iend2; i2&#43;&#43;) { const size_t idx2 = f2it-&gt;second[i2]; MapPoint* pMP2 = vpMapPoints2[idx2]; // 如果已经有匹配的点，或者遍历到的特征点对应的地图点无效 if(vbMatched2[idx2] || !pMP2) continue; if(pMP2-&gt;isBad()) continue; const cv::Mat &amp;d2 = Descriptors2.row(idx2); int dist = DescriptorDistance(d1,d2); if(dist&lt;bestDist1) { bestDist2=bestDist1; bestDist1=dist; bestIdx2=idx2; } else if(dist&lt;bestDist2) { bestDist2=dist; } } // Step 5 对匹配结果进行检查，满足阈值、最优/次优比例，记录旋转直方图信息 if(bestDist1&lt;TH_LOW) { if(static_cast&lt;float&gt;(bestDist1)&lt;mfNNratio*static_cast&lt;float&gt;(bestDist2)) { vpMatches12[idx1]=vpMapPoints2[bestIdx2]; vbMatched2[bestIdx2]=true; if(mbCheckOrientation) { float rot = vKeysUn1[idx1].angle-vKeysUn2[bestIdx2].angle; if(rot&lt;0.0) rot&#43;=360.0f; int bin = round(rot*factor); if(bin==HISTO_LENGTH) bin=0; assert(bin&gt;=0 &amp;&amp; bin&lt;HISTO_LENGTH); rotHist[bin].push_back(idx1); } nmatches&#43;&#43;; } } } f1it&#43;&#43;; f2it&#43;&#43;; } else if(f1it-&gt;first &lt; f2it-&gt;first) { f1it = vFeatVec1.lower_bound(f2it-&gt;first); } else { f2it = vFeatVec2.lower_bound(f1it-&gt;first); } } // Step 6 检查旋转直方图分布，剔除差异较大的匹配 if(mbCheckOrientation) { int ind1=-1; int ind2=-1; int ind3=-1; ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3); for(int i=0; i&lt;HISTO_LENGTH; i&#43;&#43;) { if(i==ind1 || i==ind2 || i==ind3) continue; for(size_t j=0, jend=rotHist[i].size(); j&lt;jend; j&#43;&#43;) { vpMatches12[rotHist[i][j]]=static_cast&lt;MapPoint*&gt;(NULL); nmatches--; } } } return nmatches; } </p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 图像匹配" href="https://zhouwuxiong.github.io/posts/image_match/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图像特征点
    </h2>
  </header>
  <div class="entry-content">
    <p>一个好的特征描述符应该至少保留以下特征：
旋转不变性 尺度不变性 光度不敏感 1 ORB 特征提取 124456789 ORB - (Oriented Fast and Rotated BRIEF)算法是基于FAST特征检测与BRIEF特征描述子匹配实现，相比BRIEF算法中依靠随机方式获取而值点对，ORB通过FAST方法，FAST方式寻找候选特征点方式是假设灰度图像像素点A周围的像素存在连续大于或者小于A的灰度值。
1.1 Fast 角点 FAST角点定义为：若某像素点与周围邻域足够多的像素点处于不同区域，则该像素可能为角点。考虑灰度图像，即若某像素点的灰度值比周围邻域足够多的像素点的灰度值大或小，则该点可能为角点。
对于图像中一个像素点$p$，其灰度值为$I_p$ 以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素(如下图所示) 设定一个合适的阈值$t$，如果圆上有n个连续像素点的灰度值小于$I_p−t$或者大于$I_p&#43;t$，那么这个点即可判断为角点(n的值可取12或9) 一种快速排除大部分非角点像素的方法就是检查周围1、5、9、13四个位置的像素，如果位置1和9与中心像素P点的灰度差小于给定阈值，则P点不可能是角点，直接排除；否则进一步判断位置5和13与中心像素的灰度差，如果四个像素中至少有3个像素与P点的灰度差超过阈值，则考察邻域圆上16个像素点与中心点的灰度差，如果有至少9个超过给定阈值则认为是角点。 Fast 检测出角点很多都是相邻的，Fast 对其做了非极大值一致处理，对于每个 Fast 交点使用其周围 16 个像素与中心点像素差值的绝对值之和作为得分，对于相邻的像素选择得分最大的点。
1.2 brief 特征描述符 brief 特征描述的原理是在关键点周围随机选取 N 个点对，对比像素点的像素值大小，根据其像素值的大小得到(0，1)编码，这种二进制编码的表示，可以进行快速的特征匹配和相似度计算。
1.3 旋转不变性 brief 本身不具有灰度不变性 ，为了保证旋转不变性，ORB 通过关键点邻域内的灰度质心作为特征点的主方向。计算特征描述符时先将主方向旋转为一致，再计算 brief 特征描述符，从而保证旋转不变性。但是旋转后的特征描述符虽然具有了旋转不变性，但是可区分度变弱了。如下图所示，为几种特征描述子的均值分布，横轴为均值与0.5之间的距离，纵轴为相应均值下特征点的统计数量。可以看出，BRIEF描述子所有比特位的均值接近于0.5，且方差很大；方差越大表明可区分性越好。不同特征点的描述子表现出较大的差异性，不易造成无匹配。但steered BRIEF进行了坐标旋转，损失了这个特性，导致可区分性减弱，相关性变强，不利于匹配。为了解决这个问题， ORB 使用了一种基于学习的方法来选择一定数量的随机点对，详情见 图像特征描述子之ORB | Senit_Co。
1.4 特征均匀化 在根据特征点进行位姿求解时，我们希望特征点是比较分散的而不是集中在小块的区域。因为这样可以产生更强的和约束，使得位姿求解更精确。ORB 在进行特征提取时使用了两个 tips 来均匀化特征点。1. 根据图像金字塔的分辨率比例分配每层图像需要提取的特征点数量。2. 使四叉树分裂的方式均匀化特征点，具体方法是对提取所有特征点后对图像进行四叉树分块，如果块中的特征点数量大于1个则进行继续分裂或选取响应值(Fast 交点的得分)最大的特征点，是否分裂取决于是否达到了期望的特征点数量。 1.5 Reference: 图像特征之FAST角点检测 | Senit_Co 图像特征描述子之ORB | Senit_Co Site Unreachable
2 SIFT Reference: SIFT 特征 - SLAM 之旅
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 图像特征点" href="https://zhouwuxiong.github.io/posts/feature_match/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://zhouwuxiong.github.io/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
