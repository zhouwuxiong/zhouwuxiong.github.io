<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - PaperMod">
<meta name="author" content="">
<link rel="canonical" href="https://zhouwuxiong.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zhouwuxiong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhouwuxiong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhouwuxiong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhouwuxiong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhouwuxiong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://zhouwuxiong.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://zhouwuxiong.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

>
<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
<meta property="og:url" content="https://zhouwuxiong.github.io/posts/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
      <meta property="og:image" content="https://zhouwuxiong.github.io/posts/1-feature_match.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zhouwuxiong.github.io/posts/1-feature_match.png">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zhouwuxiong.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhouwuxiong.github.io/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fr/" title="French"
                            aria-label=":fr:">Fr</a>
                    </li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhouwuxiong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ORB_SLAM2 核心代码解析
    </h2>
  </header>
  <div class="entry-content">
    <p>1 单目初始化 单目初始化分主要为4步：
特征匹配 8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果 利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。 根据计算重投影误差和视差选取最优的解。 Tips1 由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。
Tips2 F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。
2 回环检测 2.1 回环候选帧选取 ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。
图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。 组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。 Step 1 : 相似图像检测 ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。
ORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix KeyFrameDatabase::DetectLoopCandidates
Step 2 : 组连续检测 组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示： 组: 与当前帧具有一级共视关系的关键帧集合为一组 组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。
2.2 sim3 位姿求解 Sim3Solver::ComputeSim3 sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(&gt;20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to ORB_SLAM2 核心代码解析" href="https://zhouwuxiong.github.io/posts/orb_slam2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">SLAM 中的基础数学知识
    </h2>
  </header>
  <div class="entry-content">
    <p>1 旋转的表示 1.1 旋转向量 1.2 旋转矩阵 旋转矩阵有且只有一个实数特征值1； 不考虑单位矩阵，旋转矩阵的实数特征值对应的特征向量即是axis-angle表达式的旋转轴，旋转矩阵的迹与旋转角度相关。 1.3 四元数 球面线性插值（Spherical linear interpolation，slerp) ![[1-SLAM 中的基础数学知识.png]] $$ Slerp(p,q,t) = \frac{\sin[(1-t)\theta] &#43; \sin(t \theta q)}{\sin(\theta)} $$ 1.4 旋转表示之间的相互转换 四元数转旋转向量 $$ \begin{cases}{l} \theta = 2\arccos s \\ [n_x,n_y,n_z]^T = \frac{v^T}{\sin{\frac{\theta}{2}}} \end{cases} $$
旋转$\theta\boldsymbol{n}$向量转四元数 $$ \boldsymbol{q} = [\cos \frac{\theta}{2},\boldsymbol{n} \sin \frac{\theta}{2}] \tag{2} $$
旋转矩阵转旋转向量 $$ \begin{cases} \theta = \arccos(\frac{tr(\boldsymbol{R})-1}{2}) \\[1ex] n = Rn, \quad \text{轴n是R特征值为1的单位特征向量} \end{cases} \tag{3} $$
旋转向量$\boldsymbol\omega$转旋转矩阵（罗德里格斯公式） $$ \boldsymbol{R} = \cos\theta \boldsymbol{I} &#43; (1- \cos\theta ) \boldsymbol {n} \boldsymbol {n}^T &#43; \sin\theta \boldsymbol {n}^{\wedge} = exp{(\boldsymbol{\omega^{\wedge}})} \tag{4} $$ 旋转向量转旋转矩阵本质就是对应李代数的指数映射，李代数的指数映射将旋转向量映射为反对称矩阵
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to SLAM 中的基础数学知识" href="https://zhouwuxiong.github.io/posts/slam-%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图像匹配
    </h2>
  </header>
  <div class="entry-content">
    <p>1 BoW ORB_SLAM 使用 BoW 进行相似图像检索，在重定位、回环检测、参考关键帧跟踪过程中都有用到。BoW 是一种 K 叉树形式的分类树，在构造 K 叉树时，根据特征描述的相似性作为距离度量进行聚类，树的叶子节点被计为单词，每个单词使用特征点的聚类中心表示。在进行特征匹配时，根据特征点是否落在同一个叶子节点判断是否对应同一个单词，同时可以得到一个相似度得分。一般在进行图像特征匹配时会根据公共单词数量和最小的相似度得分判断图像之间的相似性。 1.1 TF-IDF TF（Term Frequency），指在单帧中某个单词的频次，频次高，权重大 IDF（Inverse Document Frequency），某个单词在词典中出现的频次，频次越低，则辨识度越高，相应权重 IDF 越大 最终 BoW 的权重是 TF*IDF ，每个单词都有自己的权重。
1.2 正向索引 再计算BoW时，每帧图像会记录一个正向索引表，记录在kd树某一层，命中的节点集合，以及节点中的特征点，用于加速两帧图像之间的特征点匹配。
1.3 逆向索引 orb-slam 中维护了一个关键帧数据库，其中有一个单词的逆向索引表，其记录了包含这个单词的关键帧和权重，用于快速查找匹配关键帧。
1.4 相似性对量 L1 ，各维度的差值的绝对值求和 余弦相似度 ，向量夹角 1.5 levelsup ORB_SLAM 在对图像生成词向量时，会根据 levelsup 记录图像中的单词落在了某层的哪些分支，这样在进行单词匹配时，只需要查找对应分支而不是从根节点开始查找，提高查找效率。 Reference: 基于词袋模型的图像匹配 - Line’s Blog
Appendix:
/* * @brief 通过词袋，对关键帧的特征点进行跟踪，该函数用于闭环检测时两个关键帧间的特征点匹配 * @details 通过bow对pKF和F中的特征点进行快速匹配（不属于同一node的特征点直接跳过匹配） * 对属于同一node的特征点通过描述子距离进行匹配 * 通过距离阈值、比例阈值和角度投票进行剔除误匹配 * @param pKF1 KeyFrame1 * @param pKF2 KeyFrame2 * @param vpMatches12 pKF2中与pKF1匹配的MapPoint，vpMatches12[i]表示匹配的地图点，null表示没有匹配，i表示匹配的pKF1 特征点索引 * @return 成功匹配的数量 */ int ORBmatcher::SearchByBoW(KeyFrame *pKF1, KeyFrame *pKF2, vector&lt;MapPoint *&gt; &amp;vpMatches12) { // Step 1 分别取出两个关键帧的特征点、BoW 向量、地图点、描述子 const vector&lt;cv::KeyPoint&gt; &amp;vKeysUn1 = pKF1-&gt;mvKeysUn; const DBoW2::FeatureVector &amp;vFeatVec1 = pKF1-&gt;mFeatVec; const vector&lt;MapPoint*&gt; vpMapPoints1 = pKF1-&gt;GetMapPointMatches(); const cv::Mat &amp;Descriptors1 = pKF1-&gt;mDescriptors; const vector&lt;cv::KeyPoint&gt; &amp;vKeysUn2 = pKF2-&gt;mvKeysUn; const DBoW2::FeatureVector &amp;vFeatVec2 = pKF2-&gt;mFeatVec; const vector&lt;MapPoint*&gt; vpMapPoints2 = pKF2-&gt;GetMapPointMatches(); const cv::Mat &amp;Descriptors2 = pKF2-&gt;mDescriptors; // 保存匹配结果 vpMatches12 = vector&lt;MapPoint*&gt;(vpMapPoints1.size(),static_cast&lt;MapPoint*&gt;(NULL)); vector&lt;bool&gt; vbMatched2(vpMapPoints2.size(),false); // Step 2 构建旋转直方图，HISTO_LENGTH = 30 vector&lt;int&gt; rotHist[HISTO_LENGTH]; for(int i=0;i&lt;HISTO_LENGTH;i&#43;&#43;) rotHist[i].reserve(500); //! 原作者代码是 const float factor = 1.0f/HISTO_LENGTH; 是错误的，更改为下面代码 const float factor = HISTO_LENGTH/360.0f; int nmatches = 0; DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin(); DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin(); DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end(); DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end(); while(f1it != f1end &amp;&amp; f2it != f2end) { // Step 3 开始遍历，分别取出属于同一node的特征点(只有属于同一node，才有可能是匹配点) if(f1it-&gt;first == f2it-&gt;first) { // 遍历KF中属于该node的特征点 for(size_t i1=0, iend1=f1it-&gt;second.size(); i1&lt;iend1; i1&#43;&#43;) { const size_t idx1 = f1it-&gt;second[i1]; MapPoint* pMP1 = vpMapPoints1[idx1]; if(!pMP1) continue; if(pMP1-&gt;isBad()) continue; const cv::Mat &amp;d1 = Descriptors1.row(idx1); int bestDist1=256; int bestIdx2 =-1 ; int bestDist2=256; // Step 4 遍历KF2中属于该node的特征点，找到了最优及次优匹配点 for(size_t i2=0, iend2=f2it-&gt;second.size(); i2&lt;iend2; i2&#43;&#43;) { const size_t idx2 = f2it-&gt;second[i2]; MapPoint* pMP2 = vpMapPoints2[idx2]; // 如果已经有匹配的点，或者遍历到的特征点对应的地图点无效 if(vbMatched2[idx2] || !pMP2) continue; if(pMP2-&gt;isBad()) continue; const cv::Mat &amp;d2 = Descriptors2.row(idx2); int dist = DescriptorDistance(d1,d2); if(dist&lt;bestDist1) { bestDist2=bestDist1; bestDist1=dist; bestIdx2=idx2; } else if(dist&lt;bestDist2) { bestDist2=dist; } } // Step 5 对匹配结果进行检查，满足阈值、最优/次优比例，记录旋转直方图信息 if(bestDist1&lt;TH_LOW) { if(static_cast&lt;float&gt;(bestDist1)&lt;mfNNratio*static_cast&lt;float&gt;(bestDist2)) { vpMatches12[idx1]=vpMapPoints2[bestIdx2]; vbMatched2[bestIdx2]=true; if(mbCheckOrientation) { float rot = vKeysUn1[idx1].angle-vKeysUn2[bestIdx2].angle; if(rot&lt;0.0) rot&#43;=360.0f; int bin = round(rot*factor); if(bin==HISTO_LENGTH) bin=0; assert(bin&gt;=0 &amp;&amp; bin&lt;HISTO_LENGTH); rotHist[bin].push_back(idx1); } nmatches&#43;&#43;; } } } f1it&#43;&#43;; f2it&#43;&#43;; } else if(f1it-&gt;first &lt; f2it-&gt;first) { f1it = vFeatVec1.lower_bound(f2it-&gt;first); } else { f2it = vFeatVec2.lower_bound(f1it-&gt;first); } } // Step 6 检查旋转直方图分布，剔除差异较大的匹配 if(mbCheckOrientation) { int ind1=-1; int ind2=-1; int ind3=-1; ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3); for(int i=0; i&lt;HISTO_LENGTH; i&#43;&#43;) { if(i==ind1 || i==ind2 || i==ind3) continue; for(size_t j=0, jend=rotHist[i].size(); j&lt;jend; j&#43;&#43;) { vpMatches12[rotHist[i][j]]=static_cast&lt;MapPoint*&gt;(NULL); nmatches--; } } } return nmatches; } </p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 图像匹配" href="https://zhouwuxiong.github.io/posts/image_match/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图像特征点
    </h2>
  </header>
  <div class="entry-content">
    <p>一个好的特征描述符应该至少保留以下特征：
旋转不变性 尺度不变性 光度不敏感 1 ORB 特征提取 124456789 ORB - (Oriented Fast and Rotated BRIEF)算法是基于FAST特征检测与BRIEF特征描述子匹配实现，相比BRIEF算法中依靠随机方式获取而值点对，ORB通过FAST方法，FAST方式寻找候选特征点方式是假设灰度图像像素点A周围的像素存在连续大于或者小于A的灰度值。
1.1 Fast 角点 FAST角点定义为：若某像素点与周围邻域足够多的像素点处于不同区域，则该像素可能为角点。考虑灰度图像，即若某像素点的灰度值比周围邻域足够多的像素点的灰度值大或小，则该点可能为角点。
对于图像中一个像素点$p$，其灰度值为$I_p$ 以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素(如下图所示) 设定一个合适的阈值$t$，如果圆上有n个连续像素点的灰度值小于$I_p−t$或者大于$I_p&#43;t$，那么这个点即可判断为角点(n的值可取12或9) 一种快速排除大部分非角点像素的方法就是检查周围1、5、9、13四个位置的像素，如果位置1和9与中心像素P点的灰度差小于给定阈值，则P点不可能是角点，直接排除；否则进一步判断位置5和13与中心像素的灰度差，如果四个像素中至少有3个像素与P点的灰度差超过阈值，则考察邻域圆上16个像素点与中心点的灰度差，如果有至少9个超过给定阈值则认为是角点。 Fast 检测出角点很多都是相邻的，Fast 对其做了非极大值一致处理，对于每个 Fast 交点使用其周围 16 个像素与中心点像素差值的绝对值之和作为得分，对于相邻的像素选择得分最大的点。
1.2 brief 特征描述符 brief 特征描述的原理是在关键点周围随机选取 N 个点对，对比像素点的像素值大小，根据其像素值的大小得到(0，1)编码，这种二进制编码的表示，可以进行快速的特征匹配和相似度计算。
1.3 旋转不变性 brief 本身不具有灰度不变性 ，为了保证旋转不变性，ORB 通过关键点邻域内的灰度质心作为特征点的主方向。计算特征描述符时先将主方向旋转为一致，再计算 brief 特征描述符，从而保证旋转不变性。但是旋转后的特征描述符虽然具有了旋转不变性，但是可区分度变弱了。如下图所示，为几种特征描述子的均值分布，横轴为均值与0.5之间的距离，纵轴为相应均值下特征点的统计数量。可以看出，BRIEF描述子所有比特位的均值接近于0.5，且方差很大；方差越大表明可区分性越好。不同特征点的描述子表现出较大的差异性，不易造成无匹配。但steered BRIEF进行了坐标旋转，损失了这个特性，导致可区分性减弱，相关性变强，不利于匹配。为了解决这个问题， ORB 使用了一种基于学习的方法来选择一定数量的随机点对，详情见 图像特征描述子之ORB | Senit_Co。
1.4 特征均匀化 在根据特征点进行位姿求解时，我们希望特征点是比较分散的而不是集中在小块的区域。因为这样可以产生更强的和约束，使得位姿求解更精确。ORB 在进行特征提取时使用了两个 tips 来均匀化特征点。1. 根据图像金字塔的分辨率比例分配每层图像需要提取的特征点数量。2. 使四叉树分裂的方式均匀化特征点，具体方法是对提取所有特征点后对图像进行四叉树分块，如果块中的特征点数量大于1个则进行继续分裂或选取响应值(Fast 交点的得分)最大的特征点，是否分裂取决于是否达到了期望的特征点数量。 1.5 Reference: 图像特征之FAST角点检测 | Senit_Co 图像特征描述子之ORB | Senit_Co Site Unreachable
2 SIFT Reference: SIFT 特征 - SLAM 之旅
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 图像特征点" href="https://zhouwuxiong.github.io/posts/feature_match/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">SLAM 基础
    </h2>
  </header>
  <div class="entry-content">
    <p>1 常见符号表示 2 SO(3)上的BCH近似公式 BCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（李代数加法 ⇔ 李群乘法），其线性近似公式广泛应用于各种函数的线性化。 在SO(3)中，某个旋转 $R$ 对应的李代数为 $\phi$，左乘一个微小旋转，记作 $\Delta{R}$，对应的李代数为 $\Delta\phi$，那么在李群上得到的结果就是 $\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\phi})^{-1}\Delta{\phi} &#43;{\phi}$ 合并后可以简单写成： $$\Delta{R}{R} = \exp(\Delta{\phi}^{\wedge})\exp({\phi}^{\wedge}) = \exp \left(({\phi} &#43; {J}_l({\phi})^{-1}\Delta{\phi})^{\wedge} \right)$$ 反过来，如果在李代数上进行加法，让一个 ${\phi}$加上小量 $\Delta{\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法： $$\exp(({\phi} &#43; \Delta{\phi})^{\wedge}) = \exp(({J}_l({\phi})\Delta{\phi})^\wedge) \exp({\phi}^\wedge)= \exp({\phi}^\wedge) \exp(({J}_r({\phi})\Delta{\phi})^\wedge) $$ 其中SO(3)的左雅克比矩阵为 $$ \begin{aligned} {J}_l(\theta{a}) &amp;= \frac{\sin\theta}{\theta}{I} &#43; (1-\frac{\sin\theta}{\theta}){a}{a}^T&#43;(\frac{1-\cos\theta}{\theta}){a}^{\wedge} \{J}^{-1}_l(\theta{a}) &amp;= \frac{\theta}{2}\cot\frac{\theta}{2}{I} &#43; (1-\frac{\theta}{2}\cot\frac{\theta}{2}){a}{a}^T-\frac{\theta}{2}{a}^{\wedge} \end{aligned} $$ 而SO(3)的右雅克比矩阵为 $$ {J}_r({\phi}) = {J}_l(-{\phi}) $$
3 KF、EKF、ESKF KF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数 Site Unreachable
KF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵 KF 假设运动方程为: $$ x_{k&#43;1} = Ax_k &#43; u_k &#43; w_k, w \sim (\mu,\sigma^2) $$ 由于该公式为线性变换，所以$x_{K&#43;1}$ 也服从高斯分布。 $$ x_{k&#43;1} \sim (A\mu &#43; u_k ,A \sigma^2 A^T) $$ EKF 假设运动方程为: $$ x_{k&#43;1} = f(x_k) &#43; u_k &#43; w_k, w \sim (\mu,\sigma^2) $$ 其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开： $$ f(x) = f(x_k) &#43; J(x-x_k) $$ 所以下一时刻的$x_{k&#43;1}$ 的分布为 $$ x_{k&#43;1} \sim (J \mu &#43; u_k, J \sigma^2 J^T) $$ 其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。 ESKF ESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-05 11:29:23 +0000 UTC'>March 5, 2024</span></footer>
  <a class="entry-link" aria-label="post link to SLAM 基础" href="https://zhouwuxiong.github.io/posts/slam-%E5%9F%BA%E7%A1%80/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://zhouwuxiong.github.io/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
