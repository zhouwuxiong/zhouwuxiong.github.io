<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ORB_SLAM2 核心代码解析 | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="1 单目初始化
单目初始化分主要为4步：

特征匹配
8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果
利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。
根据计算重投影误差和视差选取最优的解。


Tips1  由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。

Tips2  F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。
2 回环检测

2.1 回环候选帧选取
ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。

图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。
组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。

Step 1 : 相似图像检测
ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。

ORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix  KeyFrameDatabase::DetectLoopCandidates
Step 2 : 组连续检测
组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示：


组: 与当前帧具有一级共视关系的关键帧集合为一组
组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。
2.2 sim3 位姿求解  Sim3Solver::ComputeSim3
sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(&gt;20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点">
<meta name="author" content="">
<link rel="canonical" href="https://zhouwuxiong.github.io/posts/orb_slam2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zhouwuxiong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhouwuxiong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhouwuxiong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhouwuxiong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhouwuxiong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://zhouwuxiong.github.io/posts/orb_slam2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

>
<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
<meta property="og:url" content="https://zhouwuxiong.github.io/posts/orb_slam2/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="ORB_SLAM2 核心代码解析">
  <meta property="og:description" content="1 单目初始化 单目初始化分主要为4步：
特征匹配 8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果 利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。 根据计算重投影误差和视差选取最优的解。 Tips1 由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。
Tips2 F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。
2 回环检测 2.1 回环候选帧选取 ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。
图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。 组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。 Step 1 : 相似图像检测 ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。
ORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix KeyFrameDatabase::DetectLoopCandidates
Step 2 : 组连续检测 组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示： 组: 与当前帧具有一级共视关系的关键帧集合为一组 组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。
2.2 sim3 位姿求解 Sim3Solver::ComputeSim3 sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(&gt;20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T15:04:23+00:00">
    <meta property="article:modified_time" content="2024-03-07T15:04:23+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ORB_SLAM2 核心代码解析">
<meta name="twitter:description" content="1 单目初始化
单目初始化分主要为4步：

特征匹配
8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果
利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。
根据计算重投影误差和视差选取最优的解。


Tips1  由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。

Tips2  F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。
2 回环检测

2.1 回环候选帧选取
ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。

图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。
组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。

Step 1 : 相似图像检测
ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。

ORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix  KeyFrameDatabase::DetectLoopCandidates
Step 2 : 组连续检测
组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示：


组: 与当前帧具有一级共视关系的关键帧集合为一组
组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。
2.2 sim3 位姿求解  Sim3Solver::ComputeSim3
sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(&gt;20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zhouwuxiong.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ORB_SLAM2 核心代码解析",
      "item": "https://zhouwuxiong.github.io/posts/orb_slam2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ORB_SLAM2 核心代码解析",
  "name": "ORB_SLAM2 核心代码解析",
  "description": "1 单目初始化 单目初始化分主要为4步：\n特征匹配 8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果 利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。 根据计算重投影误差和视差选取最优的解。 Tips1 由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。\nTips2 F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。\n2 回环检测 2.1 回环候选帧选取 ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。\n图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。 组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。 Step 1 : 相似图像检测 ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。\nORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix KeyFrameDatabase::DetectLoopCandidates\nStep 2 : 组连续检测 组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示： 组: 与当前帧具有一级共视关系的关键帧集合为一组 组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。\n2.2 sim3 位姿求解 Sim3Solver::ComputeSim3 sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(\u0026gt;20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点\n",
  "keywords": [
    
  ],
  "articleBody": "1 单目初始化 单目初始化分主要为4步：\n特征匹配 8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果 利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。 根据计算重投影误差和视差选取最优的解。 Tips1 由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。\nTips2 F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。\n2 回环检测 2.1 回环候选帧选取 ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。\n图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。 组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。 Step 1 : 相似图像检测 ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。\nORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix KeyFrameDatabase::DetectLoopCandidates\nStep 2 : 组连续检测 组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示： 组: 与当前帧具有一级共视关系的关键帧集合为一组 组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。\n2.2 sim3 位姿求解 Sim3Solver::ComputeSim3 sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(\u003e20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点\nORBmatcher::SearchByBoW 和 ORBmatcher::SearchBySim3 在都是用特征描述符之见的距离进行匹配特征点的筛选，但是 ORBℹimatcher::SearchByBoW 使用更严格的阈值ORBmatcher::TH_LOW = 50 而ORBmatcher::SearchBySim3 使的阈值更宽松，ORBmatcher::TH_HIGH = 100。前者是为了尽量防止误匹配，后则则是为了增加约束提高求解精度，同时避免光照变化等导致特征点的匹配得分较低，而错过一些可用的特征点对，例如：车辆从相反的方向驶过同一各地方，由于提取的特征点是镜像的，所以可能导致匹配得分偏低。\n2.3 当前帧局部地图更新 在求得当前帧的回环位姿后，需要建立当前帧局部和回环帧局部地图之间的共视关系，主要包括：\n更新当前帧与回环帧之间的共视关系，因为之前通过 ORBmatcher::SearchBySim3 新增了一些当前帧和回环帧之间的匹配点，这一步主要是将匹配特征点与地图点相关联。 将回环位姿与更踪位姿的偏移量拓展到当前帧局部地图中的关键帧和地图点 将回环帧局部地图中的地图点投影当前帧的局部地图中，建立匹配关系，同时更新局部地图之间的连接关系``` 1. ![11-ORB_SLAM.png](11-ORB_SLAM.png) 2. 只获取当前帧与回环地图之间的连接关系，然后进行本质图优化。也就是联合当前帧的局部地图和回环帧的局部地图进行位姿优化 ![10-ORB_SLAM.png](10-ORB_SLAM.png) 3. 将回环帧局部地图中的地图点投影到当前帧局部地图，根据投影点匹配关系，更新局部地图帧间的共视 ### 2.4 回环位姿优化 g2o 优化最重要的是确定待优化变量(顶点)和边约束(比较确定的观测值，尽量保证这些值不边)。所以在构建图优化时，我们需要做的只有两件事，确定待优化变量、固定变量、和有哪些可用的观测约束 #### 2.4.1 本质图优化 `Optimizer::OptimizeEssentialGraph` 本质图优化的目标是在检测到闭环后，通过优化一组稀疏的关键帧位姿（Sim3位姿，包含尺度因子）来校正整个地图的累积误差。它不同于全局BA（优化所有关键帧位姿和地图点），而是只优化关键帧位姿，且仅使用共视图中的强连接边（生成树、强共视边、闭环边）来构建图结构。这样可以在保证精度的同时大幅减少计算量，实现实时优化。 顶点(待优化变量): 地图中的所有关键帧，优先使用回环优化后的sim3位姿，固定回环帧的位姿 边 (约束，一般为比较可信的相对位姿): 1. 回环约束，优先回环位姿作为观测 2. 生成树边约束，优先使用跟踪位姿作为观测 3. 历史回环边约束，优先使用历史位姿作为观测 4. 共识程度较高的边 (\u003e100)，优先使用历史关键帧作为观测 残差 相对位姿残差 \u003e 在构见本质图优化时，没有对关键帧使用边边缘化策略，并且信息矩阵设置为单位矩阵 优化完成之后，对关键帧进行词读调整，调整地图点位姿，具体做法就是使用关键帧的旧位姿将3d点变换到相机坐标后，用优化后的关键帧位姿将相机坐标系下的地图点变换到世界坐标系下。 #### 2.4.2 全局 BA `Optimizer::GlobalBundleAdjustemnt` 顶点: - 所有关键帧，0 号帧位姿被固定 - 所有地图点 边: - 地图点的重投影像素坐标作为边，但是会根据特征点在图像金子塔上层数进行加权，图层越高，可信度越差。 - 残差: - 地图点的重投影误差，特征点作为观测 \u003e BA 优化时使用了 huber 核函数抑制异常点导致的大的残差值，例如： 动态特征点 \u003e 根据特征点在不同的金子塔层数，设置协方差矩阵，低 0 层的协方差为 $I$ , 层数越高协方差矩阵的值越小，这是一种特定点进行加权的方式。 ## 3 局部地图优化 ## 4 ## 5 imu 初始化 在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合 ## 6 imu 初始化 ## 7 视觉贯导联合初始化 ## 8 Appendix ```cpp /** * @brief 在闭环检测中找到与该关键帧可能闭环的关键帧（注意不和当前帧连接） * Step 1：找出和当前帧具有公共单词的所有关键帧，不包括与当前帧连接的关键帧 * Step 2：只和具有共同单词较多的（最大数目的80%以上）关键帧进行相似度计算 * Step 3：计算上述候选帧对应的共视关键帧组的总得分，只取最高组得分75%以上的组 * Step 4：得到上述组中分数最高的关键帧作为闭环候选关键帧 * @param[in] pKF 需要闭环检测的关键帧 * @param[in] minScore 候选闭环关键帧帧和当前关键帧的BoW相似度至少要大于minScore * @return vector 闭环候选关键帧 */ vector KeyFrameDatabase::DetectLoopCandidates(KeyFrame* pKF, float minScore) { // 取出与当前关键帧相连（\u003e15个共视地图点）的所有关键帧，这些相连关键帧都是局部相连，在闭环检测的时候将被剔除 // 相连关键帧定义见 KeyFrame::UpdateConnections() set spConnectedKeyFrames = pKF-\u003eGetConnectedKeyFrames(); // 用于保存可能与当前关键帧形成闭环的候选帧（只要有相同的word，且不属于局部相连（共视）帧） list lKFsSharingWords; // Step1 根据 BoW 的逆索引查找与当前关键帧有公共单词的帧 { unique_lock lock(mMutex); // words是检测图像是否匹配的枢纽，遍历该pKF的每一个word // mBowVec 内部实际存储的是std::map // WordId 和 WordValue 表示Word在叶子中的id 和权重 for(DBoW2::BowVector::const_iterator vit=pKF-\u003emBowVec.begin(), vend=pKF-\u003emBowVec.end(); vit != vend; vit++) { // 提取所有包含该word的KeyFrame list \u0026lKFs = mvInvertedFile[vit-\u003efirst]; // 然后对这些关键帧展开遍历 for(list::iterator lit=lKFs.begin(), lend= lKFs.end(); lit!=lend; lit++) { KeyFrame* pKFi=*lit; if(pKFi-\u003emnLoopQuery!=pKF-\u003emnId) { // 还没有标记为pKF的闭环候选帧 pKFi-\u003emnLoopWords=0; // 和当前关键帧共视的话不作为闭环候选帧 if(!spConnectedKeyFrames.count(pKFi)) { // 没有共视就标记作为闭环候选关键帧，放到lKFsSharingWords里 pKFi-\u003emnLoopQuery=pKF-\u003emnId; lKFsSharingWords.push_back(pKFi); } } pKFi-\u003emnLoopWords++;// 记录pKFi与pKF具有相同word的个数 } } } // 如果没有关键帧和这个关键帧具有相同的单词,那么就返回空 if(lKFsSharingWords.empty()) return vector(); list",
  "wordCount" : "1375",
  "inLanguage": "en",
  "datePublished": "2024-03-07T15:04:23Z",
  "dateModified": "2024-03-07T15:04:23Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zhouwuxiong.github.io/posts/orb_slam2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zhouwuxiong.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhouwuxiong.github.io/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fr/" title="French"
                            aria-label=":fr:">Fr</a>
                    </li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhouwuxiong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      ORB_SLAM2 核心代码解析
    </h1>
    <div class="post-meta"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span>

</div>
  </header> 
  <div class="post-content"><h2 id="1-单目初始化">1 单目初始化<a hidden class="anchor" aria-hidden="true" href="#1-单目初始化">#</a></h2>
<p>单目初始化分主要为4步：</p>
<ol>
<li>特征匹配</li>
<li>8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果</li>
<li>利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 <code>Initializer::CheckRT</code>。</li>
<li>根据计算重投影误差和视差选取最优的解。</li>
</ol>
<blockquote>
<p>Tips1  由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。</p></blockquote>
<blockquote>
<p>Tips2  F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。</p></blockquote>
<h2 id="2-回环检测">2 回环检测<a hidden class="anchor" aria-hidden="true" href="#2-回环检测">#</a></h2>
<p><img alt="12-ORB_SLAM.png" loading="lazy" src="12-ORB_SLAM.png"></p>
<h3 id="21-回环候选帧选取">2.1 回环候选帧选取<a hidden class="anchor" aria-hidden="true" href="#21-回环候选帧选取">#</a></h3>
<p>ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。</p>
<ol>
<li>图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。</li>
<li>组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。</li>
</ol>
<p>Step 1 : 相似图像检测
ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。</p>
<blockquote>
<p>ORB_SLAM 中的<em>单词数量</em>阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix  KeyFrameDatabase::DetectLoopCandidates</p></blockquote>
<p>Step 2 : 组连续检测
组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示：
<img alt="4-ORB_SLAM.png" loading="lazy" src="4-ORB_SLAM.png"></p>
<blockquote>
<p>组: 与当前帧具有一级共视关系的关键帧集合为一组
组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。</p></blockquote>
<h3 id="22-sim3-位姿求解--sim3solvercomputesim3">2.2 sim3 位姿求解 <code> Sim3Solver::ComputeSim3</code><a hidden class="anchor" aria-hidden="true" href="#22-sim3-位姿求解--sim3solvercomputesim3">#</a></h3>
<p>sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(&gt;20)(<code>ORBmatcher::SearchByBoW</code>)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 <code>Sim3Solver::CheckInliers</code>)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 <code>ORBmatcher::SearchBySim3</code>，其具体操作时使用 sim3 位姿将地图点</p>
<blockquote>
<p><code>ORBmatcher::SearchByBoW</code> 和 <code>ORBmatcher::SearchBySim3</code> 在都是用特征描述符之见的距离进行匹配特征点的筛选，但是 <code>ORBℹimatcher::SearchByBoW</code> 使用更严格的阈值<code>ORBmatcher::TH_LOW = 50</code> 而<code>ORBmatcher::SearchBySim3</code> 使的阈值更宽松，<code>ORBmatcher::TH_HIGH = 100</code>。前者是为了尽量防止误匹配，后则则是为了增加约束提高求解精度，同时避免光照变化等导致特征点的匹配得分较低，而错过一些可用的特征点对，例如：车辆从相反的方向驶过同一各地方，由于提取的特征点是镜像的，所以可能导致匹配得分偏低。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"></code></pre></div><h3 id="23-当前帧局部地图更新">2.3 当前帧局部地图更新<a hidden class="anchor" aria-hidden="true" href="#23-当前帧局部地图更新">#</a></h3>
<p>在求得当前帧的回环位姿后，需要建立当前帧局部和回环帧局部地图之间的共视关系，主要包括：</p>
<ol>
<li>更新当前帧与回环帧之间的共视关系，因为之前通过 <code>ORBmatcher::SearchBySim3</code> 新增了一些当前帧和回环帧之间的匹配点，这一步主要是将匹配特征点与地图点相关联。
<img alt="8-ORB_SLAM.png" loading="lazy" src="8-ORB_SLAM.png"></li>
<li>将回环位姿与更踪位姿的偏移量拓展到当前帧局部地图中的关键帧和地图点
<img alt="9-ORB_SLAM.png" loading="lazy" src="9-ORB_SLAM.png"></li>
<li>将回环帧局部地图中的地图点投影当前帧的局部地图中，建立匹配关系，同时更新局部地图之间的连接关系```</li>
</ol>
<pre tabindex="0"><code class="language-。" data-lang="。">1. ![11-ORB_SLAM.png](11-ORB_SLAM.png)
2. 只获取当前帧与回环地图之间的连接关系，然后进行本质图优化。也就是联合当前帧的局部地图和回环帧的局部地图进行位姿优化
![10-ORB_SLAM.png](10-ORB_SLAM.png)
3. 将回环帧局部地图中的地图点投影到当前帧局部地图，根据投影点匹配关系，更新局部地图帧间的共视

### 2.4 回环位姿优化
g2o 优化最重要的是确定待优化变量(顶点)和边约束(比较确定的观测值，尽量保证这些值不边)。所以在构建图优化时，我们需要做的只有两件事，确定待优化变量、固定变量、和有哪些可用的观测约束
#### 2.4.1 本质图优化 `Optimizer::OptimizeEssentialGraph`
本质图优化的目标是在检测到闭环后，通过优化一组稀疏的关键帧位姿（Sim3位姿，包含尺度因子）来校正整个地图的累积误差。它不同于全局BA（优化所有关键帧位姿和地图点），而是只优化关键帧位姿，且仅使用共视图中的强连接边（生成树、强共视边、闭环边）来构建图结构。这样可以在保证精度的同时大幅减少计算量，实现实时优化。


顶点(待优化变量): 
	地图中的所有关键帧，优先使用回环优化后的sim3位姿，固定回环帧的位姿
边 (约束，一般为比较可信的相对位姿):   
	1. 回环约束，优先回环位姿作为观测
	2. 生成树边约束，优先使用跟踪位姿作为观测 
	3. 历史回环边约束，优先使用历史位姿作为观测
	4. 共识程度较高的边 (&gt;100)，优先使用历史关键帧作为观测
残差
	 相对位姿残差

&gt; 在构见本质图优化时，没有对关键帧使用边边缘化策略，并且信息矩阵设置为单位矩阵


优化完成之后，对关键帧进行词读调整，调整地图点位姿，具体做法就是使用关键帧的旧位姿将3d点变换到相机坐标后，用优化后的关键帧位姿将相机坐标系下的地图点变换到世界坐标系下。

#### 2.4.2 全局 BA `Optimizer::GlobalBundleAdjustemnt`
顶点:  
	-  所有关键帧，0 号帧位姿被固定
	-  所有地图点
边: 
	-  地图点的重投影像素坐标作为边，但是会根据特征点在图像金子塔上层数进行加权，图层越高，可信度越差。
	-  
残差: 
	-  地图点的重投影误差，特征点作为观测

&gt; BA 优化时使用了 huber 核函数抑制异常点导致的大的残差值，例如： 动态特征点
&gt; 根据特征点在不同的金子塔层数，设置协方差矩阵，低 0 层的协方差为 $I$ , 层数越高协方差矩阵的值越小，这是一种特定点进行加权的方式。

## 3 局部地图优化 


## 4 


## 5 imu 初始化 
在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合
## 6 imu 初始化 



## 7 视觉贯导联合初始化


## 8 Appendix 

```cpp
/**
 * @brief 在闭环检测中找到与该关键帧可能闭环的关键帧（注意不和当前帧连接）
 * Step 1：找出和当前帧具有公共单词的所有关键帧，不包括与当前帧连接的关键帧
 * Step 2：只和具有共同单词较多的（最大数目的80%以上）关键帧进行相似度计算 
 * Step 3：计算上述候选帧对应的共视关键帧组的总得分，只取最高组得分75%以上的组
 * Step 4：得到上述组中分数最高的关键帧作为闭环候选关键帧
 * @param[in] pKF               需要闭环检测的关键帧
 * @param[in] minScore          候选闭环关键帧帧和当前关键帧的BoW相似度至少要大于minScore
 * @return vector&lt;KeyFrame*&gt;    闭环候选关键帧
 */
vector&lt;KeyFrame*&gt; KeyFrameDatabase::DetectLoopCandidates(KeyFrame* pKF, float minScore)
{
    // 取出与当前关键帧相连（&gt;15个共视地图点）的所有关键帧，这些相连关键帧都是局部相连，在闭环检测的时候将被剔除
    // 相连关键帧定义见 KeyFrame::UpdateConnections()
    set&lt;KeyFrame*&gt; spConnectedKeyFrames = pKF-&gt;GetConnectedKeyFrames();

    // 用于保存可能与当前关键帧形成闭环的候选帧（只要有相同的word，且不属于局部相连（共视）帧）
    list&lt;KeyFrame*&gt; lKFsSharingWords;

	// Step1 根据 BoW 的逆索引查找与当前关键帧有公共单词的帧
    {
        unique_lock&lt;mutex&gt; lock(mMutex);

        // words是检测图像是否匹配的枢纽，遍历该pKF的每一个word
        // mBowVec 内部实际存储的是std::map&lt;WordId, WordValue&gt;
        // WordId 和 WordValue 表示Word在叶子中的id 和权重
        for(DBoW2::BowVector::const_iterator vit=pKF-&gt;mBowVec.begin(), vend=pKF-&gt;mBowVec.end(); vit != vend; vit++)
        {
            // 提取所有包含该word的KeyFrame
            list&lt;KeyFrame*&gt; &amp;lKFs =   mvInvertedFile[vit-&gt;first];
            // 然后对这些关键帧展开遍历
            for(list&lt;KeyFrame*&gt;::iterator lit=lKFs.begin(), lend= lKFs.end(); lit!=lend; lit++)
            {
                KeyFrame* pKFi=*lit;
                
                if(pKFi-&gt;mnLoopQuery!=pKF-&gt;mnId)    
                {
                    // 还没有标记为pKF的闭环候选帧
                    pKFi-&gt;mnLoopWords=0;
                    // 和当前关键帧共视的话不作为闭环候选帧
                    if(!spConnectedKeyFrames.count(pKFi))
                    {
                        // 没有共视就标记作为闭环候选关键帧，放到lKFsSharingWords里
                        pKFi-&gt;mnLoopQuery=pKF-&gt;mnId;
                        lKFsSharingWords.push_back(pKFi);
                    }
                }
                pKFi-&gt;mnLoopWords++;// 记录pKFi与pKF具有相同word的个数
            }
        }
    }

    // 如果没有关键帧和这个关键帧具有相同的单词,那么就返回空
    if(lKFsSharingWords.empty())
        return vector&lt;KeyFrame*&gt;();

    list&lt;pair&lt;float,KeyFrame*&gt; &gt; lScoreAndMatch;

    // Only compare against those keyframes that share enough words
    // Step 2：统计上述所有闭环候选帧中与当前帧具有共同单词最多的单词数，用来决定相对阈值 
    int maxCommonWords=0;
    for(list&lt;KeyFrame*&gt;::iterator lit=lKFsSharingWords.begin(), lend= lKFsSharingWords.end(); lit!=lend; lit++)
    {
        if((*lit)-&gt;mnLoopWords&gt;maxCommonWords)
            maxCommonWords=(*lit)-&gt;mnLoopWords;
    }

    // 确定最小公共单词数为最大公共单词数目的0.8倍
    int minCommonWords = maxCommonWords*0.8f;

    int nscores=0;

    // Compute similarity score. Retain the matches whose score is higher than minScore
    // Step 3：遍历上述所有闭环候选帧，挑选出共有单词数大于 minCommonWords 且单词匹配度大于 minScore 存入 lScoreAndMatch
    for(list&lt;KeyFrame*&gt;::iterator lit=lKFsSharingWords.begin(), lend= lKFsSharingWords.end(); lit!=lend; lit++)
    {
        KeyFrame* pKFi = *lit;
        if(pKFi-&gt;mnLoopWords&gt; minCommonWords )
        {
            nscores++;
            float si = mpVoc-&gt;score(pKF-&gt;mBowVec,pKFi-&gt;mBowVec);
            pKFi-&gt;mLoopScore = si;
            if(si&gt;=minScore)
                lScoreAndMatch.push_back(make_pair(si,pKFi));
        }
    }
    if(lScoreAndMatch.empty())
        return vector&lt;KeyFrame*&gt;();


    list&lt;pair&lt;float,KeyFrame*&gt; &gt; lAccScoreAndMatch;
    float bestAccScore = minScore;

    // Step 4：计算当前帧与候选帧的共视帧之间的相似度累计值，从中选取累计相似度最高的帧，这样可以保证在后续进行位姿求解时有足够的共视约束
    for(list&lt;pair&lt;float,KeyFrame*&gt; &gt;::iterator it=lScoreAndMatch.begin(), itend=lScoreAndMatch.end(); it!=itend; it++)
    {
        KeyFrame* pKFi = it-&gt;second;
        vector&lt;KeyFrame*&gt; vpNeighs = pKFi-&gt;GetBestCovisibilityKeyFrames(10);

        float bestScore = it-&gt;first; // 该组最高分数
        float accScore = it-&gt;first;  // 该组累计得分
        KeyFrame* pBestKF = pKFi;    // 该组最高分数对应的关键帧
        // 遍历共视关键帧，累计得分 
        for(vector&lt;KeyFrame*&gt;::iterator vit=vpNeighs.begin(), vend=vpNeighs.end(); vit!=vend; vit++)
        {
            KeyFrame* pKF2 = *vit;
            // 只有pKF2也在闭环候选帧中，且公共单词数超过最小要求，才能贡献分数
            if(pKF2-&gt;mnLoopQuery==pKF-&gt;mnId &amp;&amp; pKF2-&gt;mnLoopWords&gt; minCommonWords )
            {
                accScore+=pKF2-&gt;mLoopScore;
                // 统计得到组里分数最高的关键帧
                if(pKF2-&gt;mLoopScore&gt;bestScore)
                {
                    pBestKF=pKF2;
                    bestScore = pKF2-&gt;mLoopScore;
                }
            }
        }

        lAccScoreAndMatch.push_back(make_pair(accScore,pBestKF));
        // 记录所有组中组得分最高的组，用于确定相对阈值
        if(accScore&gt;bestAccScore)
            bestAccScore=accScore;
    }

    // Return all those keyframes with a score higher than 0.75*bestScore
    // 所有组中最高得分的0.75倍，作为最低阈值
    float minScoreToRetain = 0.75f*bestAccScore;

    set&lt;KeyFrame*&gt; spAlreadyAddedKF;
    vector&lt;KeyFrame*&gt; vpLoopCandidates;
    vpLoopCandidates.reserve(lAccScoreAndMatch.size());

    // Step 5：只取组得分大于阈值的组，得到组中分数最高的关键帧们作为闭环候选关键帧
    for(list&lt;pair&lt;float,KeyFrame*&gt; &gt;::iterator it=lAccScoreAndMatch.begin(), itend=lAccScoreAndMatch.end(); it!=itend; it++)
    {
        if(it-&gt;first&gt;minScoreToRetain)
        {
            KeyFrame* pKFi = it-&gt;second;
            // spAlreadyAddedKF 是为了防止重复添加
            if(!spAlreadyAddedKF.count(pKFi))
            {
                vpLoopCandidates.push_back(pKFi);
                spAlreadyAddedKF.insert(pKFi);
            }
        }
    }

    return vpLoopCandidates;
}
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Sim3Solver</span><span class="o">::</span><span class="n">ComputeSim3</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">P1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">P2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Sim3计算过程参考论文:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Horn 1987, Closed-form solution of absolute orientataion using unit quaternions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 1: 定义3D点质心及去质心后的点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// O1和O2分别为P1和P2矩阵中3D点的质心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Pr1和Pr2为减去质心后的3D点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">Pr1</span><span class="p">(</span><span class="n">P1</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">P1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span> <span class="c1">// Relative coordinates to centroid (set 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">Pr2</span><span class="p">(</span><span class="n">P2</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">P2</span><span class="p">.</span><span class="n">type</span><span class="p">());</span> <span class="c1">// Relative coordinates to centroid (set 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">O1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Pr1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span> <span class="c1">// Centroid of P1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">O2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Pr2</span><span class="p">.</span><span class="n">type</span><span class="p">());</span> <span class="c1">// Centroid of P2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">ComputeCentroid</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span><span class="n">Pr1</span><span class="p">,</span><span class="n">O1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ComputeCentroid</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span><span class="n">Pr2</span><span class="p">,</span><span class="n">O2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 2: 计算论文中三维点数目n&gt;3的 M 矩阵。这里只使用了3个点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Pr2 对应论文中 r_l,i&#39;，Pr1 对应论文中 r_r,i&#39;,计算的是P2到P1的Sim3，论文中是left 到 right的Sim3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Pr2</span><span class="o">*</span><span class="n">Pr1</span><span class="p">.</span><span class="n">t</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 3: 计算论文中的 N 矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">N11</span><span class="p">,</span> <span class="n">N12</span><span class="p">,</span> <span class="n">N13</span><span class="p">,</span> <span class="n">N14</span><span class="p">,</span> <span class="n">N22</span><span class="p">,</span> <span class="n">N23</span><span class="p">,</span> <span class="n">N24</span><span class="p">,</span> <span class="n">N33</span><span class="p">,</span> <span class="n">N34</span><span class="p">,</span> <span class="n">N44</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">N</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">P1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">N11</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>   <span class="c1">// Sxx+Syy+Szz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">N12</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>                    <span class="c1">// Syz-Szy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">N13</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>                    <span class="c1">// Szx-Sxz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">N14</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>                    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">N22</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N23</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N24</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N33</span> <span class="o">=</span> <span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N34</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N44</span> <span class="o">=</span> <span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">N11</span><span class="p">,</span> <span class="n">N12</span><span class="p">,</span> <span class="n">N13</span><span class="p">,</span> <span class="n">N14</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">N12</span><span class="p">,</span> <span class="n">N22</span><span class="p">,</span> <span class="n">N23</span><span class="p">,</span> <span class="n">N24</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">N13</span><span class="p">,</span> <span class="n">N23</span><span class="p">,</span> <span class="n">N33</span><span class="p">,</span> <span class="n">N34</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">N14</span><span class="p">,</span> <span class="n">N24</span><span class="p">,</span> <span class="n">N34</span><span class="p">,</span> <span class="n">N44</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 4: 特征值分解求最大特征值对应的特征向量，就是我们要求的旋转四元数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">eval</span><span class="p">,</span> <span class="n">evec</span><span class="p">;</span>  <span class="c1">// val vec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 特征值默认是从大到小排列，所以evec[0] 是最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">eigen</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// N 矩阵最大特征值（第一个特征值）对应特征向量就是要求的四元数（q0 q1 q2 q3），其中q0 是实部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将(q1 q2 q3)放入vec（四元数的虚部）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">vec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">evec</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">evec</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">colRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span> <span class="c1">//extract imaginary part of the quaternion (sin*axis)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Rotation angle. sin is the norm of the imaginary part, cos is the real part
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 四元数虚部模长 norm(vec)=sin(theta/2), 四元数实部 evec.at&lt;float&gt;(0,0)=q0=cos(theta/2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这一步的ang实际是theta/2，theta 是旋转向量中旋转角度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ? 这里也可以用 arccos(q0)=angle/2 得到旋转角吧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">ang</span><span class="o">=</span><span class="n">atan2</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span><span class="n">evec</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// vec/norm(vec)归一化得到归一化后的旋转向量,然后乘上角度得到包含了旋转轴和旋转角信息的旋转向量vec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vec</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">ang</span><span class="o">*</span><span class="n">vec</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span> <span class="c1">//Angle-axis x. quaternion angle is the half
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">mR12i</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">P1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 旋转向量（轴角）转换为旋转矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">mR12i</span><span class="p">);</span> <span class="c1">// computes the rotation matrix from angle-axis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 5: Rotate set 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 利用刚计算出来的旋转将三维点旋转到同一个坐标系，P3对应论文里的 r_l,i&#39;, Pr1 对应论文里的r_r,i&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">P3</span> <span class="o">=</span> <span class="n">mR12i</span><span class="o">*</span><span class="n">Pr2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 6: 计算尺度因子 Scale
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mbFixScale</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 论文中有2个求尺度方法。一个是p632右中的位置，考虑了尺度的对称性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 代码里实际使用的是另一种方法，这个公式对应着论文中p632左中位置的那个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Pr1 对应论文里的r_r,i&#39;,P3对应论文里的 r_l,i&#39;,(经过坐标系转换的Pr2), n=3, 剩下的就和论文中都一样了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">double</span> <span class="n">nom</span> <span class="o">=</span> <span class="n">Pr1</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 准备计算分母
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">aux_P3</span><span class="p">(</span><span class="n">P3</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">P3</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">aux_P3</span><span class="o">=</span><span class="n">P3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先得到平方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cv</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">P3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">aux_P3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">den</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 然后再累加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">aux_P3</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">aux_P3</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">den</span><span class="o">+=</span><span class="n">aux_P3</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">ms12i</span> <span class="o">=</span> <span class="n">nom</span><span class="o">/</span><span class="n">den</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">ms12i</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 7: 计算平移Translation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mt12i</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">P1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 论文中平移公式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mt12i</span> <span class="o">=</span> <span class="n">O1</span> <span class="o">-</span> <span class="n">ms12i</span><span class="o">*</span><span class="n">mR12i</span><span class="o">*</span><span class="n">O2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 8: 计算双向变换矩阵，目的是在后面的检查的过程中能够进行双向的投影操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 8.1 用尺度，旋转，平移构建变换矩阵 T12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mT12i</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">P1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">sR</span> <span class="o">=</span> <span class="n">ms12i</span><span class="o">*</span><span class="n">mR12i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//         |sR t|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// mT12i = | 0 1|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sR</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">mT12i</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">colRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">mt12i</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">mT12i</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">col</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 8.2 T21
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">mT21i</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">P1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">sRinv</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">ms12i</span><span class="p">)</span><span class="o">*</span><span class="n">mR12i</span><span class="p">.</span><span class="n">t</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">sRinv</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">mT21i</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">colRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">tinv</span> <span class="o">=</span> <span class="o">-</span><span class="n">sRinv</span><span class="o">*</span><span class="n">mt12i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tinv</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">mT21i</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">col</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 用位姿来对特征匹配点三角化，从中筛选中合格的三维点
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] R                                     旋转矩阵R
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] t                                     平移矩阵t
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] vKeys1                                参考帧特征点  
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] vKeys2                                当前帧特征点
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] vMatches12                            两帧特征点的匹配关系
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] vbMatchesInliers                      特征点对内点标记
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] K                                     相机内参矩阵
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in &amp; out] vP3D                            三角化测量之后的特征点的空间坐标
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in] th2                                   重投影误差的阈值
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in &amp; out] vbGood                          标记成功三角化点？
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param[in &amp; out] parallax                        计算出来的比较大的视差角（注意不是最大，具体看后面代码）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return int 
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Initializer</span><span class="o">::</span><span class="n">CheckRT</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">R</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">KeyPoint</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vKeys1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">KeyPoint</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vKeys2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Match</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vMatches12</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vbMatchesInliers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point3f</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vP3D</span><span class="p">,</span> <span class="kt">float</span> <span class="n">th2</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vbGood</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">parallax</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// 对给出的特征点对及其R t , 通过三角化检查解的有效性，也称为 cheirality check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Calibration parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//从相机内参数矩阵获取相机的校正参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">float</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">K</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">fy</span> <span class="o">=</span> <span class="n">K</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">K</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">K</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//特征点是否是good点的标记，这里的特征点指的是参考帧中的特征点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vbGood</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vKeys1</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//重设存储空间坐标的点的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vP3D</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vKeys1</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//存储计算出来的每对特征点的视差
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vCosParallax</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vCosParallax</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">vKeys1</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Camera 1 Projection Matrix K[I|0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Step 1：计算相机的投影矩阵  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 投影矩阵P是一个 3x4 的矩阵，可以将空间中的一个点投影到平面上，获得其平面坐标，这里均指的是齐次坐标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于第一个相机是 P1=K*[I|0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 以第一个相机的光心作为世界坐标系, 定义相机的投影矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">P1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span>				<span class="c1">//矩阵的大小是3x4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			   <span class="n">CV_32F</span><span class="p">,</span>			<span class="c1">//数据类型是浮点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			   <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>	<span class="c1">//初始的数值是0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//将整个K矩阵拷贝到P1矩阵的左侧3x3矩阵，因为 K*I = K
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">K</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">P1</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">colRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第一个相机的光心设置为世界坐标系下的原点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">O1</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Camera 2 Projection Matrix K[R|t]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 计算第二个相机的投影矩阵 P2=K*[R|t]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">P2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">R</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">P2</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">colRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">P2</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">).</span><span class="n">col</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//最终结果是K*[R|t]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P2</span> <span class="o">=</span> <span class="n">K</span><span class="o">*</span><span class="n">P2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第二个相机的光心在世界坐标系下的坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">O2</span> <span class="o">=</span> <span class="o">-</span><span class="n">R</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//在遍历开始前，先将good点计数设置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">nGood</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 开始遍历所有的特征点对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iend</span><span class="o">=</span><span class="n">vMatches12</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">&lt;</span><span class="n">iend</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 跳过outliers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vbMatchesInliers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Step 2 获取特征点对，调用Triangulate() 函数进行三角化，得到三角化测量之后的3D点坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// kp1和kp2是匹配好的有效特征点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">KeyPoint</span> <span class="o">&amp;</span><span class="n">kp1</span> <span class="o">=</span> <span class="n">vKeys1</span><span class="p">[</span><span class="n">vMatches12</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">KeyPoint</span> <span class="o">&amp;</span><span class="n">kp2</span> <span class="o">=</span> <span class="n">vKeys2</span><span class="p">[</span><span class="n">vMatches12</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//存储三维点的的坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">p3dC1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 利用三角法恢复三维点p3dC1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Triangulate</span><span class="p">(</span><span class="n">kp1</span><span class="p">,</span><span class="n">kp2</span><span class="p">,</span>	<span class="c1">//特征点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">P1</span><span class="p">,</span><span class="n">P2</span><span class="p">,</span>		<span class="c1">//投影矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">p3dC1</span><span class="p">);</span>		<span class="c1">//输出，三角化测量之后特征点的空间坐标		
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Step 3 第一关：检查三角化的三维点坐标是否合法（非无穷值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 只要三角测量的结果中有一个是无穷大的就说明三角化失败，跳过对当前点的处理，进行下一对特征点的遍历 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isfinite</span><span class="p">(</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="n">isfinite</span><span class="p">(</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="n">isfinite</span><span class="p">(</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//其实这里就算是不这样写也没问题，因为默认的匹配点对就不是good点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">vbGood</span><span class="p">[</span><span class="n">vMatches12</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//继续对下一对匹配点的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check parallax
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Step 4 第二关：通过三维点深度值正负、两相机光心视差角大小来检查是否合法 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">//得到向量PO1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">normal1</span> <span class="o">=</span> <span class="n">p3dC1</span> <span class="o">-</span> <span class="n">O1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//求取模长，其实就是距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">dist1</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">norm</span><span class="p">(</span><span class="n">normal1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">//同理构造向量PO2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">normal2</span> <span class="o">=</span> <span class="n">p3dC1</span> <span class="o">-</span> <span class="n">O2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//求模长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">dist2</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">norm</span><span class="p">(</span><span class="n">normal2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">//根据公式：a.*b=|a||b|cos_theta 可以推导出来下面的式子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">cosParallax</span> <span class="o">=</span> <span class="n">normal1</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dist1</span><span class="o">*</span><span class="n">dist2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check depth in front of first camera (only if enough parallax, as &#34;infinite&#34; points can easily go to negative depth)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果深度值为负值，为非法三维点跳过该匹配点对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ?视差比较小时，重投影误差比较大。这里0.99998 对应的角度为0.36°,这里不应该是 cosParallax&gt;0.99998 吗？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ?因为后面判断vbGood 点时的条件也是 cosParallax&lt;0.99998 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// !可能导致初始化不稳定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cosParallax</span><span class="o">&lt;</span><span class="mf">0.99998</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check depth in front of second camera (only if enough parallax, as &#34;infinite&#34; points can easily go to negative depth)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 讲空间点p3dC1变换到第2个相机坐标系下变为p3dC2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">p3dC2</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">p3dC1</span><span class="o">+</span><span class="n">t</span><span class="p">;</span>	
</span></span><span class="line"><span class="cl">		<span class="c1">//判断过程和上面的相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p3dC2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cosParallax</span><span class="o">&lt;</span><span class="mf">0.99998</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Step 5 第三关：计算空间点在参考帧和当前帧上的重投影误差，如果大于阈值则舍弃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Check reprojection error in first image
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 计算3D点在第一个图像上的投影误差
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//投影到参考帧图像上的点的坐标x,y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">im1x</span><span class="p">,</span> <span class="n">im1y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//这个使能空间点的z坐标的倒数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">invZ1</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//投影到参考帧图像上。因为参考帧下的相机坐标系和世界坐标系重合，因此这里就直接进行投影就可以了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">im1x</span> <span class="o">=</span> <span class="n">fx</span><span class="o">*</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">invZ1</span><span class="o">+</span><span class="n">cx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">im1y</span> <span class="o">=</span> <span class="n">fy</span><span class="o">*</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">invZ1</span><span class="o">+</span><span class="n">cy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">//参考帧上的重投影误差，这个的确就是按照定义来的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">squareError1</span> <span class="o">=</span> <span class="p">(</span><span class="n">im1x</span><span class="o">-</span><span class="n">kp1</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">im1x</span><span class="o">-</span><span class="n">kp1</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">im1y</span><span class="o">-</span><span class="n">kp1</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">im1y</span><span class="o">-</span><span class="n">kp1</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 重投影误差太大，跳过淘汰
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">squareError1</span><span class="o">&gt;</span><span class="n">th2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check reprojection error in second image
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 计算3D点在第二个图像上的投影误差，计算过程和第一个图像类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">im2x</span><span class="p">,</span> <span class="n">im2y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意这里的p3dC2已经是第二个相机坐标系下的三维点了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">invZ2</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">p3dC2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">im2x</span> <span class="o">=</span> <span class="n">fx</span><span class="o">*</span><span class="n">p3dC2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">invZ2</span><span class="o">+</span><span class="n">cx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">im2y</span> <span class="o">=</span> <span class="n">fy</span><span class="o">*</span><span class="n">p3dC2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">invZ2</span><span class="o">+</span><span class="n">cy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 计算重投影误差
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">squareError2</span> <span class="o">=</span> <span class="p">(</span><span class="n">im2x</span><span class="o">-</span><span class="n">kp2</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">im2x</span><span class="o">-</span><span class="n">kp2</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">im2y</span><span class="o">-</span><span class="n">kp2</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">im2y</span><span class="o">-</span><span class="n">kp2</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 重投影误差太大，跳过淘汰
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">squareError2</span><span class="o">&gt;</span><span class="n">th2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Step 6 统计经过检验的3D点个数，记录3D点视差角 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果运行到这里就说明当前遍历的这个特征点对靠谱，经过了重重检验，说明是一个合格的点，称之为good点 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vCosParallax</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cosParallax</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//存储这个三角化测量后的3D点在世界坐标系下的坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vP3D</span><span class="p">[</span><span class="n">vMatches12</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3f</span><span class="p">(</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">p3dC1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//good点计数++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">nGood</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">//判断视差角，只有视差角稍稍大一丢丢的才会给打good点标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//? bug 我觉得这个写的位置不太对。你的good点计数都++了然后才判断，不是会让good点标志和good点计数不一样吗
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">cosParallax</span><span class="o">&lt;</span><span class="mf">0.99998</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">vbGood</span><span class="p">[</span><span class="n">vMatches12</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 7 得到3D点中较小的视差角，并且转换成为角度制表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">nGood</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从小到大排序，注意vCosParallax值越大，视差越小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sort</span><span class="p">(</span><span class="n">vCosParallax</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vCosParallax</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// !排序后并没有取最小的视差角，而是取一个较小的视差角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 作者的做法：如果经过检验过后的有效3D点小于50个，那么就取最后那个最小的视差角(cos值最大)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 如果大于50个，就取排名第50个的较小的视差角即可，为了避免3D点太多时出现太小的视差角 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="kt">int</span><span class="p">(</span><span class="n">vCosParallax</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//将这个选中的角弧度制转换为角度制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">parallax</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">vCosParallax</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">CV_PI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//如果没有good点那么这个就直接设置为0了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">parallax</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//返回good点计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">nGood</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
