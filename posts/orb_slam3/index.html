<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ORB_SLAM3 核心代码解析 | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="1 VIO 联合初始化
视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。
在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合

2 Step1 单目初始化 MonocularInitialization
单目初始化在 Tracking 中进行
3 Step2 imu 初始化 InitializeIMU()
imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 InitializeIMU() ，imu 初始化主要分为4各阶段，前三个阶段都使用InitializeIMU 进行图优化。

为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。
第一次阶段的执行 条件是(关键帧数量&gt;10 并且距离初始关键帧的时间&gt;1s) , InitializeIMU 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化InertialOptimization。
第二和和第三界阶段使用同样调用 InitializeIMU() 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 InitializeIMU 进行初始化，而不是向第一阶段一样只调用一次。
第四阶段为重力方向和尺度精修ScaleRefinement，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。
3.1 InertialOptimization
在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 InertialOptimization 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。
">
<meta name="author" content="">
<link rel="canonical" href="https://zhouwuxiong.github.io/posts/orb_slam3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zhouwuxiong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhouwuxiong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhouwuxiong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhouwuxiong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhouwuxiong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://zhouwuxiong.github.io/posts/orb_slam3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

>
<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
<meta property="og:url" content="https://zhouwuxiong.github.io/posts/orb_slam3/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="ORB_SLAM3 核心代码解析">
  <meta property="og:description" content="1 VIO 联合初始化 视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。
在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合 2 Step1 单目初始化 MonocularInitialization 单目初始化在 Tracking 中进行
3 Step2 imu 初始化 InitializeIMU() imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 InitializeIMU() ，imu 初始化主要分为4各阶段，前三个阶段都使用InitializeIMU 进行图优化。
为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。
第一次阶段的执行 条件是(关键帧数量&gt;10 并且距离初始关键帧的时间&gt;1s) , InitializeIMU 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化InertialOptimization。
第二和和第三界阶段使用同样调用 InitializeIMU() 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 InitializeIMU 进行初始化，而不是向第一阶段一样只调用一次。
第四阶段为重力方向和尺度精修ScaleRefinement，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。
3.1 InertialOptimization 在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 InertialOptimization 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。 ">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T15:04:23+00:00">
    <meta property="article:modified_time" content="2024-03-07T15:04:23+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ORB_SLAM3 核心代码解析">
<meta name="twitter:description" content="1 VIO 联合初始化
视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。
在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合

2 Step1 单目初始化 MonocularInitialization
单目初始化在 Tracking 中进行
3 Step2 imu 初始化 InitializeIMU()
imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 InitializeIMU() ，imu 初始化主要分为4各阶段，前三个阶段都使用InitializeIMU 进行图优化。

为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。
第一次阶段的执行 条件是(关键帧数量&gt;10 并且距离初始关键帧的时间&gt;1s) , InitializeIMU 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化InertialOptimization。
第二和和第三界阶段使用同样调用 InitializeIMU() 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 InitializeIMU 进行初始化，而不是向第一阶段一样只调用一次。
第四阶段为重力方向和尺度精修ScaleRefinement，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。
3.1 InertialOptimization
在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 InertialOptimization 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。
">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zhouwuxiong.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ORB_SLAM3 核心代码解析",
      "item": "https://zhouwuxiong.github.io/posts/orb_slam3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ORB_SLAM3 核心代码解析",
  "name": "ORB_SLAM3 核心代码解析",
  "description": "1 VIO 联合初始化 视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。\n在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合 2 Step1 单目初始化 MonocularInitialization 单目初始化在 Tracking 中进行\n3 Step2 imu 初始化 InitializeIMU() imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 InitializeIMU() ，imu 初始化主要分为4各阶段，前三个阶段都使用InitializeIMU 进行图优化。\n为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。\n第一次阶段的执行 条件是(关键帧数量\u0026gt;10 并且距离初始关键帧的时间\u0026gt;1s) , InitializeIMU 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化InertialOptimization。\n第二和和第三界阶段使用同样调用 InitializeIMU() 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 InitializeIMU 进行初始化，而不是向第一阶段一样只调用一次。\n第四阶段为重力方向和尺度精修ScaleRefinement，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。\n3.1 InertialOptimization 在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 InertialOptimization 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。 ",
  "keywords": [
    
  ],
  "articleBody": "1 VIO 联合初始化 视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。\n在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合 2 Step1 单目初始化 MonocularInitialization 单目初始化在 Tracking 中进行\n3 Step2 imu 初始化 InitializeIMU() imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 InitializeIMU() ，imu 初始化主要分为4各阶段，前三个阶段都使用InitializeIMU 进行图优化。\n为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。\n第一次阶段的执行 条件是(关键帧数量\u003e10 并且距离初始关键帧的时间\u003e1s) , InitializeIMU 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化InertialOptimization。\n第二和和第三界阶段使用同样调用 InitializeIMU() 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 InitializeIMU 进行初始化，而不是向第一阶段一样只调用一次。\n第四阶段为重力方向和尺度精修ScaleRefinement，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。\n3.1 InertialOptimization 在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 InertialOptimization 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。 3.2 FullInertialBA ORB-SLAM3：FullInertialBA()代码分析-CSDN博客\n3.3 尺度和重力方向优化 4 视觉贯导联合初始化 5 Reference Site Unreachable\n6 Appendix /** * @brief imu初始化 * @param priorG 陀螺仪偏置的信息矩阵系数，主动设置时一般bInit为true，也就是只优化最后一帧的偏置，这个数会作为计算信息矩阵时使用 * @param priorA 加速度计偏置的信息矩阵系数 * @param bFIBA 是否做BA优化，目前都为true */ void LocalMapping::InitializeIMU(float priorG, float priorA, bool bFIBA) { // 1. 将所有关键帧放入列表及向量里，且查看是否满足初始化条件 if (mbResetRequested) return; float minTime; int nMinKF; // 从时间及帧数上限制初始化，不满足下面的不进行初始化 if (mbMonocular) { minTime = 2.0; // 10s nMinKF = 10; // 10 KF } else { minTime = 1.0; nMinKF = 10; } // 当前地图大于10帧才进行初始化 if(mpAtlas-\u003eKeyFramesInMap()\u003cnMinKF) return; // Retrieve all keyframe in temporal order // 按照顺序存放目前地图里的关键帧，顺序按照前后顺序(Id)来，包括当前关键帧 list\u003cKeyFrame*\u003e lpKF; KeyFrame* pKF = mpCurrentKeyFrame; while(pKF-\u003emPrevKF) { lpKF.push_front(pKF); pKF = pKF-\u003emPrevKF; } lpKF.push_front(pKF); // 同样内容再构建一个和lpKF一样的容器vpKF vector\u003cKeyFrame*\u003e vpKF(lpKF.begin(),lpKF.end()); if(vpKF.size()\u003cnMinKF) return; mFirstTs=vpKF.front()-\u003emTimeStamp; if(mpCurrentKeyFrame-\u003emTimeStamp-mFirstTs\u003cminTime) return; // 正在做IMU的初始化，在 tracking 里面使用，如果为 true ，暂不添加关键帧 bInitializing = true; // 先处理新关键帧，防止堆积且保证数据量充足 while(CheckNewKeyFrames()) { ProcessNewKeyFrame(); vpKF.push_back(mpCurrentKeyFrame); lpKF.push_back(mpCurrentKeyFrame); } // 2. 正式IMU初始化 const int N = vpKF.size(); IMU::Bias b(0,0,0,0,0,0); // Compute and KF velocities mRwg estimation // 在IMU连一次初始化都没有做的情况下 if (!mpCurrentKeyFrame-\u003eGetMap()-\u003eisImuInitialized()) { Eigen::Matrix3f Rwg; Eigen::Vector3f dirG; dirG.setZero(); int have_imu_num = 0; for(vector\u003cKeyFrame*\u003e::iterator itKF = vpKF.begin(); itKF!=vpKF.end(); itKF++) { if (!(*itKF)-\u003empImuPreintegrated) continue; if (!(*itKF)-\u003emPrevKF) // first Frame continue; have_imu_num++; // 初始化时关于速度的预积分定义 Ri.t()*(s*Vj - s*Vi - Rwg*g*tij) // mPrevKF-\u003eGetImuRotation() 为视觉里程计估计的旋转 // GetUpdatedDeltaVelocity() 为 IMU 估计的速度增量 // dirG 将 IMU 估计的速度增量(g*t)变换到世界坐标系(第一帧图像坐标系)下然后进行累加 dirG -= (*itKF)-\u003emPrevKF-\u003eGetImuRotation() * (*itKF)-\u003empImuPreintegrated-\u003eGetUpdatedDeltaVelocity(); // 求取实际的速度，位移/时间 （根据视觉里程计估计IMU的速度） Eigen::Vector3f _vel = ((*itKF)-\u003eGetImuPosition() - (*itKF)-\u003emPrevKF-\u003eGetImuPosition())/(*itKF)-\u003empImuPreintegrated-\u003edT; (*itKF)-\u003eSetVelocity(_vel); (*itKF)-\u003emPrevKF-\u003eSetVelocity(_vel); } if (have_imu_num \u003c 6) { cout \u003c\u003c \"imu初始化失败, 由于带有imu预积分信息的关键帧数量太少\" \u003c\u003c endl; bInitializing=false; mbBadImu = true; return; } // ------------- 计算相机坐标系下的重力方向与物理世界重力方向的夹角 -------------------- // // dirG = sV1 - sVn + n*Rwg*g*t // (这里假设了速度变化很小，即处于匀速运动或静止，此时IMU 测量的速度的增量方向与重力加速度的方向一致， // 所以 dirG 代表了 IMU 测量的重力加速度方向，而 gI 则代表了视觉里程计坐标下下的 z 轴，接下来算他们的夹角将 z 轴矫正到与重力方向对齐) // 归一化，约等于重力在世界坐标系下的方向 dirG = dirG/dirG.norm(); // 物理世界的重力方向 Eigen::Vector3f gI(0.0f, 0.0f, -1.0f); // 求“重力在重力坐标系下的方向”与的“重力在世界坐标系（纯视觉）下的方向”叉乘 Eigen::Vector3f v = gI.cross(dirG); // 求叉乘模长 const float nv = v.norm(); // 求转角大小 const float cosg = gI.dot(dirG); const float ang = acos(cosg); // v/nv 表示垂直于两个向量的轴 ang 表示转的角度，组成角轴 Eigen::Vector3f vzg = v*ang/nv; // 获得重力坐标系到世界坐标系(视觉里程计坐标系)的旋转矩阵的初值 Rwg = Sophus::SO3f::exp(vzg).matrix(); mRwg = Rwg.cast\u003cdouble\u003e(); mTinit = mpCurrentKeyFrame-\u003emTimeStamp-mFirstTs; } else { mRwg = Eigen::Matrix3d::Identity(); mbg = mpCurrentKeyFrame-\u003eGetGyroBias().cast\u003cdouble\u003e(); mba = mpCurrentKeyFrame-\u003eGetAccBias().cast\u003cdouble\u003e(); } mScale=1.0; // 暂时没发现在别的地方出现过 mInitTime = mpTracker-\u003emLastFrame.mTimeStamp-vpKF.front()-\u003emTimeStamp; std::chrono::steady_clock::time_point t0 = std::chrono::steady_clock::now(); // 3. 计算残差及偏置差，优化尺度重力方向及速度偏置，偏置先验为0，双目时不优化尺度 Optimizer::InertialOptimization(mpAtlas-\u003eGetCurrentMap(), mRwg, mScale, mbg, mba, mbMonocular, infoInertial, false, false, priorG, priorA); std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now(); // 尺度太小的话初始化认为失败 if (mScale\u003c1e-1) { cout \u003c\u003c \"scale too small\" \u003c\u003c endl; bInitializing=false; return; } // 到此时为止，前面做的东西没有改变map // Before this line we are not changing the map { unique_lock\u003cmutex\u003e lock(mpAtlas-\u003eGetCurrentMap()-\u003emMutexMapUpdate); // 尺度变化超过设定值，或者非单目时（无论带不带imu，但这个函数只在带imu时才执行，所以这个可以理解为双目imu） if ((fabs(mScale - 1.f) \u003e 0.00001) || !mbMonocular) { // 4.1 恢复重力方向与尺度信息 Sophus::SE3f Twg(mRwg.cast\u003cfloat\u003e().transpose(), Eigen::Vector3f::Zero()); mpAtlas-\u003eGetCurrentMap()-\u003eApplyScaledRotation(Twg, mScale, true); // 4.2 更新普通帧的位姿，主要是当前帧与上一帧 mpTracker-\u003eUpdateFrameIMU(mScale, vpKF[0]-\u003eGetImuBias(), mpCurrentKeyFrame); } // Check if initialization OK // 即使初始化成功后面还会执行这个函数重新初始化 // 在之前没有初始化成功情况下（此时刚刚初始化成功）对每一帧都标记，后面的kf全部都在tracking里面标记为true // 也就是初始化之前的那些关键帧即使有imu信息也不算 if (!mpAtlas-\u003eisImuInitialized()) for (int i = 0; i \u003c N; i++) { KeyFrame *pKF2 = vpKF[i]; pKF2-\u003ebImu = true; } } // TODO 这步更新是否有必要做待研究，0.4版本是放在FullInertialBA下面做的 // 这个版本FullInertialBA不直接更新位姿及三位点了 mpTracker-\u003eUpdateFrameIMU(1.0,vpKF[0]-\u003eGetImuBias(),mpCurrentKeyFrame); // 设置经过初始化了 if (!mpAtlas-\u003eisImuInitialized()) { // ! 重要！标记初始化成功 mpAtlas-\u003eSetImuInitialized(); mpTracker-\u003et0IMU = mpTracker-\u003emCurrentFrame.mTimeStamp; mpCurrentKeyFrame-\u003ebImu = true; } std::chrono::steady_clock::time_point t4 = std::chrono::steady_clock::now(); // 代码里都为true if (bFIBA) { // 5. 承接上一步纯imu优化，按照之前的结果更新了尺度信息及适应重力方向，所以要结合地图进行一次视觉加imu的全局优化，这次带了MP等信息 // ! 1.0版本里面不直接赋值了，而是将所有优化后的信息保存到变量里面 if (priorA!=0.f) Optimizer::FullInertialBA(mpAtlas-\u003eGetCurrentMap(), 100, false, mpCurrentKeyFrame-\u003emnId, NULL, true, priorG, priorA); else Optimizer::FullInertialBA(mpAtlas-\u003eGetCurrentMap(), 100, false, mpCurrentKeyFrame-\u003emnId, NULL, false); } std::chrono::steady_clock::time_point t5 = std::chrono::steady_clock::now(); Verbose::PrintMess(\"Global Bundle Adjustment finished\\nUpdating map ...\", Verbose::VERBOSITY_NORMAL); // Get Map Mutex unique_lock\u003cmutex\u003e lock(mpAtlas-\u003eGetCurrentMap()-\u003emMutexMapUpdate); unsigned long GBAid = mpCurrentKeyFrame-\u003emnId; // Process keyframes in the queue // 6. 处理一下新来的关键帧，这些关键帧没有参与优化，但是这部分bInitializing为true，只在第2次跟第3次初始化会有新的关键帧进来 // 这部分关键帧也需要被更新 while(CheckNewKeyFrames()) { ProcessNewKeyFrame(); vpKF.push_back(mpCurrentKeyFrame); lpKF.push_back(mpCurrentKeyFrame); } // Correct keyframes starting at map first keyframe // 7. 更新位姿与三维点 // 获取地图中初始关键帧，第一帧肯定经过修正的 list\u003cKeyFrame*\u003e lpKFtoCheck(mpAtlas-\u003eGetCurrentMap()-\u003emvpKeyFrameOrigins.begin(),mpAtlas-\u003eGetCurrentMap()-\u003emvpKeyFrameOrigins.end()); // 初始就一个关键帧，顺藤摸瓜找到父子相连的所有关键帧 // 类似于树的广度优先搜索，其实也就是根据父子关系遍历所有的关键帧，有的参与了FullInertialBA有的没参与 while(!lpKFtoCheck.empty()) { // 7.1 获得这个关键帧的子关键帧 KeyFrame* pKF = lpKFtoCheck.front(); const set\u003cKeyFrame*\u003e sChilds = pKF-\u003eGetChilds(); Sophus::SE3f Twc = pKF-\u003eGetPoseInverse(); // 获得关键帧的优化前的位姿 // 7.2 遍历这个关键帧所有的子关键帧 for(set\u003cKeyFrame*\u003e::const_iterator sit=sChilds.begin();sit!=sChilds.end();sit++) { // 确认是否能用 KeyFrame* pChild = *sit; if(!pChild || pChild-\u003eisBad()) continue; // 这个判定为true表示pChild没有参与前面的优化，因此要根据已经优化过的更新，结果全部暂存至变量 if(pChild-\u003emnBAGlobalForKF!=GBAid) { // pChild-\u003eGetPose()也是优化前的位姿，Twc也是优化前的位姿 // 7.3 因此他们的相对位姿是比较准的，可以用于更新pChild的位姿 Sophus::SE3f Tchildc = pChild-\u003eGetPose() * Twc; // 使用相对位姿，根据pKF优化后的位姿更新pChild位姿，最后结果都暂时放于mTcwGBA pChild-\u003emTcwGBA = Tchildc * pKF-\u003emTcwGBA; // 7.4 使用相同手段更新速度 Sophus::SO3f Rcor = pChild-\u003emTcwGBA.so3().inverse() * pChild-\u003eGetPose().so3(); if(pChild-\u003eisVelocitySet()){ pChild-\u003emVwbGBA = Rcor * pChild-\u003eGetVelocity(); } else { Verbose::PrintMess(\"Child velocity empty!! \", Verbose::VERBOSITY_NORMAL); } pChild-\u003emBiasGBA = pChild-\u003eGetImuBias(); pChild-\u003emnBAGlobalForKF = GBAid; } // 加入到list中，再去寻找pChild的子关键帧 lpKFtoCheck.push_back(pChild); } // 7.5 此时pKF的利用价值就没了，但是里面的数值还都是优化前的，优化后的全部放于类似mTcwGBA这样的变量中 // 所以要更新到正式的状态里，另外mTcwBefGBA要记录更新前的位姿，用于同样的手段更新三维点用 pKF-\u003emTcwBefGBA = pKF-\u003eGetPose(); pKF-\u003eSetPose(pKF-\u003emTcwGBA); // 速度偏置同样更新 if(pKF-\u003ebImu) { pKF-\u003emVwbBefGBA = pKF-\u003eGetVelocity(); pKF-\u003eSetVelocity(pKF-\u003emVwbGBA); pKF-\u003eSetNewBias(pKF-\u003emBiasGBA); } else { cout \u003c\u003c \"KF \" \u003c\u003c pKF-\u003emnId \u003c\u003c \" not set to inertial!! \\n\"; } // pop lpKFtoCheck.pop_front(); } // Correct MapPoints // 8. 更新三维点，三维点在优化后同样没有正式的更新，而是找了个中间变量保存了优化后的数值 const vector\u003cMapPoint*\u003e vpMPs = mpAtlas-\u003eGetCurrentMap()-\u003eGetAllMapPoints(); for(size_t i=0; i\u003cvpMPs.size(); i++) { MapPoint* pMP = vpMPs[i]; if(pMP-\u003eisBad()) continue; // 8.1 如果这个点参与了全局优化，那么直接使用优化后的值来赋值 if(pMP-\u003emnBAGlobalForKF==GBAid) { // If optimized by Global BA, just update pMP-\u003eSetWorldPos(pMP-\u003emPosGBA); } // 如果没有参与，与关键帧的更新方式类似 else { // Update according to the correction of its reference keyframe KeyFrame* pRefKF = pMP-\u003eGetReferenceKeyFrame(); if(pRefKF-\u003emnBAGlobalForKF!=GBAid) continue; // Map to non-corrected camera // 8.2 根据优化前的世界坐标系下三维点的坐标以及优化前的关键帧位姿计算这个点在关键帧下的坐标 Eigen::Vector3f Xc = pRefKF-\u003emTcwBefGBA * pMP-\u003eGetWorldPos(); // Backproject using corrected camera // 8.3 根据优化后的位姿转到世界坐标系下作为这个点优化后的三维坐标 pMP-\u003eSetWorldPos(pRefKF-\u003eGetPoseInverse() * Xc); } } Verbose::PrintMess(\"Map updated!\", Verbose::VERBOSITY_NORMAL); mnKFs=vpKF.size(); mIdxInit++; // 9. 再有新的来就不要了~不然陷入无限套娃了 for(list\u003cKeyFrame*\u003e::iterator lit = mlNewKeyFrames.begin(), lend=mlNewKeyFrames.end(); lit!=lend; lit++) { (*lit)-\u003eSetBadFlag(); delete *lit; } mlNewKeyFrames.clear(); mpTracker-\u003emState=Tracking::OK; bInitializing = false; mpCurrentKeyFrame-\u003eGetMap()-\u003eIncreaseChangeIndex(); return; } ",
  "wordCount" : "870",
  "inLanguage": "en",
  "datePublished": "2024-03-07T15:04:23Z",
  "dateModified": "2024-03-07T15:04:23Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zhouwuxiong.github.io/posts/orb_slam3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zhouwuxiong.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhouwuxiong.github.io/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fr/" title="French"
                            aria-label=":fr:">Fr</a>
                    </li>
                    <li>
                        <a href="https://zhouwuxiong.github.io/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhouwuxiong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://zhouwuxiong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      ORB_SLAM3 核心代码解析
    </h1>
    <div class="post-meta"><span title='2024-03-07 15:04:23 +0000 UTC'>March 7, 2024</span>

</div>
  </header> 
  <div class="post-content"><h2 id="1-vio-联合初始化">1 VIO 联合初始化<a hidden class="anchor" aria-hidden="true" href="#1-vio-联合初始化">#</a></h2>
<p>视觉惯性初始化是为了给惯性变量一个良好的初值，这些变量包括重力方向、零偏、尺度等。首先 IMU 的零偏是不固定的，它会受到温度、硬件老化、电磁干扰等因素的影响，并且 IMU 的零偏对测量值的影响较大，所以一般在每次系统启动时都需要进行单独的初始化。在纯视觉初始化以第一帧图像的图像坐标系为原点， 而 IMU 输出的是角速度和加速度，当前 IMU 静止时任会受到重力加速度的影响，我们在进行速度积分运算时需要减掉重力的积分值。当 IMU 静止时我们可以很容易确定重力的方向，但是 SLAM 系统往往是即时启动，我们需要运动过程中估计重力方向。通过 IMU 估计得到重力方向后我们就可以将图像坐标系的Z轴和重力方向对齐，从而避免建出的地图倾斜。</p>
<p>在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合
<img alt="3-ORB_SLAM3.png" loading="lazy" src="3-ORB_SLAM3.png"></p>
<h2 id="2-step1-单目初始化-monocularinitialization">2 Step1 单目初始化 <code>MonocularInitialization</code><a hidden class="anchor" aria-hidden="true" href="#2-step1-单目初始化-monocularinitialization">#</a></h2>
<p>单目初始化在 Tracking 中进行</p>
<h2 id="3-step2-imu-初始化-initializeimu">3 Step2 imu 初始化 <code>InitializeIMU()</code><a hidden class="anchor" aria-hidden="true" href="#3-step2-imu-初始化-initializeimu">#</a></h2>
<p>imu 初始化子在单目初始化完成之后进行，会以较高的频率（4～10Hz）插入关键帧进行 IMU 的初始化，执行函数为 <code>InitializeIMU()</code> ，imu 初始化主要分为4各阶段，前三个阶段都使用<code>InitializeIMU</code> 进行图优化。</p>
<blockquote>
<p>为什么要进行高频率的插入，是因为关键帧之间的时间间隔比较短时，IMU 之间的预积分量的不确定性也较低，在 2s 内基本可以生成是十几个关键帧和地图点。同时在短时间内(2s内)，我们可以假定系统是是静止的，方便对重力方向进行初值估计。</p></blockquote>
<p>第一次阶段的执行 条件是(关键帧数量&gt;10 并且距离初始关键帧的时间&gt;1s) , <code>InitializeIMU</code> 首先计算了重力方向和视觉坐标系方向的相对旋转作为初值，需要注意的是这里假设了 1s 的系统是静止或匀速运动的，对运动方程做了简化，此时速度的增量完全由重力加速度产生，因此只需要计算速度增量与视觉坐标系的夹角 即可得重力方向矫正的旋转角(dirg)。然后以视觉位姿作为观测，对预积分方做图优化<code>InertialOptimization</code>。</p>
<p>第二和和第三界阶段使用同样调用 <code>InitializeIMU()</code> 函数执行，只是调高了（ ba、bg） 的置信度（ PriorA、PriorG），可以理解为逐步精细的求解(ba、bg)。并且第二、第三阶段会在每次加入新的关键帧时都调用 <code>InitializeIMU</code> 进行初始化，而不是向第一阶段一样只调用一次。</p>
<p>第四阶段为重力方向和尺度精修<code>ScaleRefinement</code>，具体做法是固定图优化中的其它顶点，只优化重力方向和尺度。这个阶段是在每次累积一定数量的关键帧后进行。</p>
<h3 id="31-inertialoptimization">3.1 <code>InertialOptimization</code><a hidden class="anchor" aria-hidden="true" href="#31-inertialoptimization">#</a></h3>
<p>在进行图优化时我们主要需要考虑三个问题，优化量、约束(固定量)、残差、初值。 在 <code>InertialOptimization</code> 的优化问题中，优化量为重力方向，尺度，速度与偏置；固定量为视觉观测位姿，残差为预积分的 delta 量；初值，重力方向(dirg)，尺度(1.0)，速度(视觉里程计估计的速度)，ba和bg(0)。
<img alt="1-ORB_SLAM3.png" loading="lazy" src="1-ORB_SLAM3.png"></p>
<h3 id="32-fullinertialba">3.2 <code>FullInertialBA</code><a hidden class="anchor" aria-hidden="true" href="#32-fullinertialba">#</a></h3>
<p><a href="https://blog.csdn.net/weixin_46363611/article/details/113567082">ORB-SLAM3：FullInertialBA()代码分析-CSDN博客</a></p>
<h3 id="33-尺度和重力方向优化">3.3 尺度和重力方向优化<a hidden class="anchor" aria-hidden="true" href="#33-尺度和重力方向优化">#</a></h3>
<h2 id="4-视觉贯导联合初始化">4 视觉贯导联合初始化<a hidden class="anchor" aria-hidden="true" href="#4-视觉贯导联合初始化">#</a></h2>
<h2 id="5-reference">5 Reference<a hidden class="anchor" aria-hidden="true" href="#5-reference">#</a></h2>
<p><a href="https://blog.csdn.net/guanjing_dream/article/details/128824320">Site Unreachable</a></p>
<h2 id="6-appendix">6 Appendix<a hidden class="anchor" aria-hidden="true" href="#6-appendix">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/** 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief imu初始化
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param priorG 陀螺仪偏置的信息矩阵系数，主动设置时一般bInit为true，也就是只优化最后一帧的偏置，这个数会作为计算信息矩阵时使用
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param priorA 加速度计偏置的信息矩阵系数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param bFIBA 是否做BA优化，目前都为true
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LocalMapping</span><span class="o">::</span><span class="n">InitializeIMU</span><span class="p">(</span><span class="kt">float</span> <span class="n">priorG</span><span class="p">,</span> <span class="kt">float</span> <span class="n">priorA</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bFIBA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 将所有关键帧放入列表及向量里，且查看是否满足初始化条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">mbResetRequested</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">minTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nMinKF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从时间及帧数上限制初始化，不满足下面的不进行初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">mbMonocular</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">minTime</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>  <span class="c1">// 10s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">nMinKF</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>    <span class="c1">// 10 KF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">minTime</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nMinKF</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前地图大于10帧才进行初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">KeyFramesInMap</span><span class="p">()</span><span class="o">&lt;</span><span class="n">nMinKF</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Retrieve all keyframe in temporal order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 按照顺序存放目前地图里的关键帧，顺序按照前后顺序(Id)来，包括当前关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;</span> <span class="n">lpKF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyFrame</span><span class="o">*</span> <span class="n">pKF</span> <span class="o">=</span> <span class="n">mpCurrentKeyFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mPrevKF</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lpKF</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">pKF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pKF</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mPrevKF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">lpKF</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">pKF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 同样内容再构建一个和lpKF一样的容器vpKF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;</span> <span class="n">vpKF</span><span class="p">(</span><span class="n">lpKF</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">lpKF</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">vpKF</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">nMinKF</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mFirstTs</span><span class="o">=</span><span class="n">vpKF</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mTimeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">mTimeStamp</span><span class="o">-</span><span class="n">mFirstTs</span><span class="o">&lt;</span><span class="n">minTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 正在做IMU的初始化，在 tracking 里面使用，如果为 true ，暂不添加关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bInitializing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 先处理新关键帧，防止堆积且保证数据量充足
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">CheckNewKeyFrames</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProcessNewKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vpKF</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mpCurrentKeyFrame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">lpKF</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mpCurrentKeyFrame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 正式IMU初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">vpKF</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">IMU</span><span class="o">::</span><span class="n">Bias</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Compute and KF velocities mRwg estimation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在IMU连一次初始化都没有做的情况下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">GetMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isImuInitialized</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3f</span> <span class="n">Rwg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">dirG</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dirG</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">have_imu_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">itKF</span> <span class="o">=</span> <span class="n">vpKF</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itKF</span><span class="o">!=</span><span class="n">vpKF</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itKF</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mpImuPreintegrated</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mPrevKF</span><span class="p">)</span> <span class="c1">// first Frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">have_imu_num</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 初始化时关于速度的预积分定义 Ri.t()*(s*Vj - s*Vi - Rwg*g*tij)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// mPrevKF-&gt;GetImuRotation() 为视觉里程计估计的旋转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// GetUpdatedDeltaVelocity() 为 IMU 估计的速度增量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// dirG 将 IMU 估计的速度增量(g*t)变换到世界坐标系(第一帧图像坐标系)下然后进行累加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">dirG</span> <span class="o">-=</span> <span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mPrevKF</span><span class="o">-&gt;</span><span class="n">GetImuRotation</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mpImuPreintegrated</span><span class="o">-&gt;</span><span class="n">GetUpdatedDeltaVelocity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 求取实际的速度，位移/时间 （根据视觉里程计估计IMU的速度）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">_vel</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetImuPosition</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mPrevKF</span><span class="o">-&gt;</span><span class="n">GetImuPosition</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mpImuPreintegrated</span><span class="o">-&gt;</span><span class="n">dT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetVelocity</span><span class="p">(</span><span class="n">_vel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="n">itKF</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mPrevKF</span><span class="o">-&gt;</span><span class="n">SetVelocity</span><span class="p">(</span><span class="n">_vel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">have_imu_num</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;imu初始化失败, 由于带有imu预积分信息的关键帧数量太少&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">bInitializing</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">mbBadImu</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// -------------  计算相机坐标系下的重力方向与物理世界重力方向的夹角 -------------------- //
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// dirG = sV1 - sVn + n*Rwg*g*t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// (这里假设了速度变化很小，即处于匀速运动或静止，此时IMU 测量的速度的增量方向与重力加速度的方向一致，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以 dirG 代表了 IMU 测量的重力加速度方向，而 gI 则代表了视觉里程计坐标下下的 z 轴，接下来算他们的夹角将 z 轴矫正到与重力方向对齐)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 归一化，约等于重力在世界坐标系下的方向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">dirG</span> <span class="o">=</span> <span class="n">dirG</span><span class="o">/</span><span class="n">dirG</span><span class="p">.</span><span class="n">norm</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 物理世界的重力方向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">gI</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求“重力在重力坐标系下的方向”与的“重力在世界坐标系（纯视觉）下的方向”叉乘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">v</span> <span class="o">=</span> <span class="n">gI</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dirG</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求叉乘模长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="kt">float</span> <span class="n">nv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">norm</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求转角大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="kt">float</span> <span class="n">cosg</span> <span class="o">=</span> <span class="n">gI</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dirG</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">float</span> <span class="n">ang</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">cosg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// v/nv 表示垂直于两个向量的轴  ang 表示转的角度，组成角轴
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">vzg</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">ang</span><span class="o">/</span><span class="n">nv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获得重力坐标系到世界坐标系(视觉里程计坐标系)的旋转矩阵的初值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Rwg</span> <span class="o">=</span> <span class="n">Sophus</span><span class="o">::</span><span class="n">SO3f</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="n">vzg</span><span class="p">).</span><span class="n">matrix</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">mRwg</span> <span class="o">=</span> <span class="n">Rwg</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">mTinit</span> <span class="o">=</span> <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">mTimeStamp</span><span class="o">-</span><span class="n">mFirstTs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mRwg</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">mbg</span> <span class="o">=</span> <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">GetGyroBias</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">mba</span> <span class="o">=</span> <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">GetAccBias</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mScale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 暂时没发现在别的地方出现过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mInitTime</span> <span class="o">=</span> <span class="n">mpTracker</span><span class="o">-&gt;</span><span class="n">mLastFrame</span><span class="p">.</span><span class="n">mTimeStamp</span><span class="o">-</span><span class="n">vpKF</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mTimeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 计算残差及偏置差，优化尺度重力方向及速度偏置，偏置先验为0，双目时不优化尺度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Optimizer</span><span class="o">::</span><span class="n">InertialOptimization</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">(),</span> <span class="n">mRwg</span><span class="p">,</span> <span class="n">mScale</span><span class="p">,</span> <span class="n">mbg</span><span class="p">,</span> <span class="n">mba</span><span class="p">,</span> <span class="n">mbMonocular</span><span class="p">,</span> <span class="n">infoInertial</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">priorG</span><span class="p">,</span> <span class="n">priorA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 尺度太小的话初始化认为失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">mScale</span><span class="o">&lt;</span><span class="mf">1e-1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;scale too small&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">bInitializing</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 到此时为止，前面做的东西没有改变map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Before this line we are not changing the map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mMutexMapUpdate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 尺度变化超过设定值，或者非单目时（无论带不带imu，但这个函数只在带imu时才执行，所以这个可以理解为双目imu）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">((</span><span class="n">fabs</span><span class="p">(</span><span class="n">mScale</span> <span class="o">-</span> <span class="mf">1.f</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbMonocular</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 4.1 恢复重力方向与尺度信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Sophus</span><span class="o">::</span><span class="n">SE3f</span> <span class="n">Twg</span><span class="p">(</span><span class="n">mRwg</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">().</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">Zero</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ApplyScaledRotation</span><span class="p">(</span><span class="n">Twg</span><span class="p">,</span> <span class="n">mScale</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 4.2 更新普通帧的位姿，主要是当前帧与上一帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">mpTracker</span><span class="o">-&gt;</span><span class="n">UpdateFrameIMU</span><span class="p">(</span><span class="n">mScale</span><span class="p">,</span> <span class="n">vpKF</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">GetImuBias</span><span class="p">(),</span> <span class="n">mpCurrentKeyFrame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check if initialization OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 即使初始化成功后面还会执行这个函数重新初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在之前没有初始化成功情况下（此时刚刚初始化成功）对每一帧都标记，后面的kf全部都在tracking里面标记为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 也就是初始化之前的那些关键帧即使有imu信息也不算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">isImuInitialized</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">KeyFrame</span> <span class="o">*</span><span class="n">pKF2</span> <span class="o">=</span> <span class="n">vpKF</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">pKF2</span><span class="o">-&gt;</span><span class="n">bImu</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO 这步更新是否有必要做待研究，0.4版本是放在FullInertialBA下面做的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个版本FullInertialBA不直接更新位姿及三位点了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mpTracker</span><span class="o">-&gt;</span><span class="n">UpdateFrameIMU</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="n">vpKF</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">GetImuBias</span><span class="p">(),</span><span class="n">mpCurrentKeyFrame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置经过初始化了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">isImuInitialized</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ! 重要！标记初始化成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">SetImuInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">mpTracker</span><span class="o">-&gt;</span><span class="n">t0IMU</span> <span class="o">=</span> <span class="n">mpTracker</span><span class="o">-&gt;</span><span class="n">mCurrentFrame</span><span class="p">.</span><span class="n">mTimeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">bImu</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">t4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 代码里都为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">bFIBA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 承接上一步纯imu优化，按照之前的结果更新了尺度信息及适应重力方向，所以要结合地图进行一次视觉加imu的全局优化，这次带了MP等信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ! 1.0版本里面不直接赋值了，而是将所有优化后的信息保存到变量里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">priorA</span><span class="o">!=</span><span class="mf">0.f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">Optimizer</span><span class="o">::</span><span class="n">FullInertialBA</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">(),</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">priorG</span><span class="p">,</span> <span class="n">priorA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">Optimizer</span><span class="o">::</span><span class="n">FullInertialBA</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">(),</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">t5</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Verbose</span><span class="o">::</span><span class="n">PrintMess</span><span class="p">(</span><span class="s">&#34;Global Bundle Adjustment finished</span><span class="se">\n</span><span class="s">Updating map ...&#34;</span><span class="p">,</span> <span class="n">Verbose</span><span class="o">::</span><span class="n">VERBOSITY_NORMAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Get Map Mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mMutexMapUpdate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">GBAid</span> <span class="o">=</span> <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Process keyframes in the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 6. 处理一下新来的关键帧，这些关键帧没有参与优化，但是这部分bInitializing为true，只在第2次跟第3次初始化会有新的关键帧进来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这部分关键帧也需要被更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">CheckNewKeyFrames</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProcessNewKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vpKF</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mpCurrentKeyFrame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">lpKF</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mpCurrentKeyFrame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Correct keyframes starting at map first keyframe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 7. 更新位姿与三维点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 获取地图中初始关键帧，第一帧肯定经过修正的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;</span> <span class="n">lpKFtoCheck</span><span class="p">(</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mvpKeyFrameOrigins</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mvpKeyFrameOrigins</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始就一个关键帧，顺藤摸瓜找到父子相连的所有关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 类似于树的广度优先搜索，其实也就是根据父子关系遍历所有的关键帧，有的参与了FullInertialBA有的没参与
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">lpKFtoCheck</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 7.1 获得这个关键帧的子关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">KeyFrame</span><span class="o">*</span> <span class="n">pKF</span> <span class="o">=</span> <span class="n">lpKFtoCheck</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;</span> <span class="n">sChilds</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">GetChilds</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Sophus</span><span class="o">::</span><span class="n">SE3f</span> <span class="n">Twc</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">GetPoseInverse</span><span class="p">();</span>  <span class="c1">// 获得关键帧的优化前的位姿
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 7.2 遍历这个关键帧所有的子关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">sit</span><span class="o">=</span><span class="n">sChilds</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">sit</span><span class="o">!=</span><span class="n">sChilds</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">sit</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 确认是否能用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">KeyFrame</span><span class="o">*</span> <span class="n">pChild</span> <span class="o">=</span> <span class="o">*</span><span class="n">sit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pChild</span> <span class="o">||</span> <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">isBad</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 这个判定为true表示pChild没有参与前面的优化，因此要根据已经优化过的更新，结果全部暂存至变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">pChild</span><span class="o">-&gt;</span><span class="n">mnBAGlobalForKF</span><span class="o">!=</span><span class="n">GBAid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// pChild-&gt;GetPose()也是优化前的位姿，Twc也是优化前的位姿
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 7.3 因此他们的相对位姿是比较准的，可以用于更新pChild的位姿
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">Sophus</span><span class="o">::</span><span class="n">SE3f</span> <span class="n">Tchildc</span> <span class="o">=</span> <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">GetPose</span><span class="p">()</span> <span class="o">*</span> <span class="n">Twc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 使用相对位姿，根据pKF优化后的位姿更新pChild位姿，最后结果都暂时放于mTcwGBA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">mTcwGBA</span> <span class="o">=</span> <span class="n">Tchildc</span> <span class="o">*</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mTcwGBA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 7.4 使用相同手段更新速度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">Sophus</span><span class="o">::</span><span class="n">SO3f</span> <span class="n">Rcor</span> <span class="o">=</span> <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">mTcwGBA</span><span class="p">.</span><span class="n">so3</span><span class="p">().</span><span class="n">inverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">GetPose</span><span class="p">().</span><span class="n">so3</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">pChild</span><span class="o">-&gt;</span><span class="n">isVelocitySet</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">mVwbGBA</span> <span class="o">=</span> <span class="n">Rcor</span> <span class="o">*</span> <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">GetVelocity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Verbose</span><span class="o">::</span><span class="n">PrintMess</span><span class="p">(</span><span class="s">&#34;Child velocity empty!! &#34;</span><span class="p">,</span> <span class="n">Verbose</span><span class="o">::</span><span class="n">VERBOSITY_NORMAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">mBiasGBA</span> <span class="o">=</span> <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">GetImuBias</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">mnBAGlobalForKF</span> <span class="o">=</span> <span class="n">GBAid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 加入到list中，再去寻找pChild的子关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">lpKFtoCheck</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 7.5 此时pKF的利用价值就没了，但是里面的数值还都是优化前的，优化后的全部放于类似mTcwGBA这样的变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以要更新到正式的状态里，另外mTcwBefGBA要记录更新前的位姿，用于同样的手段更新三维点用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mTcwBefGBA</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">GetPose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">SetPose</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mTcwGBA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 速度偏置同样更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">bImu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mVwbBefGBA</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">GetVelocity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">SetVelocity</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mVwbGBA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">SetNewBias</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mBiasGBA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;KF &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mnId</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; not set to inertial!! </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// pop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">lpKFtoCheck</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Correct MapPoints
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 8. 更新三维点，三维点在优化后同样没有正式的更新，而是找了个中间变量保存了优化后的数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">MapPoint</span><span class="o">*&gt;</span> <span class="n">vpMPs</span> <span class="o">=</span> <span class="n">mpAtlas</span><span class="o">-&gt;</span><span class="n">GetCurrentMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetAllMapPoints</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">vpMPs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">MapPoint</span><span class="o">*</span> <span class="n">pMP</span> <span class="o">=</span> <span class="n">vpMPs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">pMP</span><span class="o">-&gt;</span><span class="n">isBad</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 8.1 如果这个点参与了全局优化，那么直接使用优化后的值来赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">pMP</span><span class="o">-&gt;</span><span class="n">mnBAGlobalForKF</span><span class="o">==</span><span class="n">GBAid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// If optimized by Global BA, just update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">SetWorldPos</span><span class="p">(</span><span class="n">pMP</span><span class="o">-&gt;</span><span class="n">mPosGBA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果没有参与，与关键帧的更新方式类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Update according to the correction of its reference keyframe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">KeyFrame</span><span class="o">*</span> <span class="n">pRefKF</span> <span class="o">=</span> <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">GetReferenceKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">pRefKF</span><span class="o">-&gt;</span><span class="n">mnBAGlobalForKF</span><span class="o">!=</span><span class="n">GBAid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Map to non-corrected camera
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 8.2 根据优化前的世界坐标系下三维点的坐标以及优化前的关键帧位姿计算这个点在关键帧下的坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">Xc</span> <span class="o">=</span> <span class="n">pRefKF</span><span class="o">-&gt;</span><span class="n">mTcwBefGBA</span> <span class="o">*</span> <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">GetWorldPos</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Backproject using corrected camera
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 8.3 根据优化后的位姿转到世界坐标系下作为这个点优化后的三维坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">SetWorldPos</span><span class="p">(</span><span class="n">pRefKF</span><span class="o">-&gt;</span><span class="n">GetPoseInverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">Xc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Verbose</span><span class="o">::</span><span class="n">PrintMess</span><span class="p">(</span><span class="s">&#34;Map updated!&#34;</span><span class="p">,</span> <span class="n">Verbose</span><span class="o">::</span><span class="n">VERBOSITY_NORMAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mnKFs</span><span class="o">=</span><span class="n">vpKF</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mIdxInit</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 9. 再有新的来就不要了~不然陷入无限套娃了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">list</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">lit</span> <span class="o">=</span> <span class="n">mlNewKeyFrames</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lend</span><span class="o">=</span><span class="n">mlNewKeyFrames</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">lit</span><span class="o">!=</span><span class="n">lend</span><span class="p">;</span> <span class="n">lit</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">lit</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetBadFlag</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="o">*</span><span class="n">lit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlNewKeyFrames</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mpTracker</span><span class="o">-&gt;</span><span class="n">mState</span><span class="o">=</span><span class="n">Tracking</span><span class="o">::</span><span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bInitializing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mpCurrentKeyFrame</span><span class="o">-&gt;</span><span class="n">GetMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IncreaseChangeIndex</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
