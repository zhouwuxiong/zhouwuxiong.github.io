[{"content":"一个好的特征描述符应该至少保留以下特征：\n旋转不变性 尺度不变性 光度不敏感 1 ORB 特征提取 ORB - (Oriented Fast and Rotated BRIEF)算法是基于FAST特征检测与BRIEF特征描述子匹配实现，相比BRIEF算法中依靠随机方式获取而值点对，ORB通过FAST方法，FAST方式寻找候选特征点方式是假设灰度图像像素点A周围的像素存在连续大于或者小于A的灰度值。\n1.1 Fast 角点 FAST角点定义为：若某像素点与周围邻域足够多的像素点处于不同区域，则该像素可能为角点。考虑灰度图像，即若某像素点的灰度值比周围邻域足够多的像素点的灰度值大或小，则该点可能为角点。\n对于图像中一个像素点$p$，其灰度值为$I_p$ 以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素(如下图所示) 设定一个合适的阈值$t$，如果圆上有n个连续像素点的灰度值小于$I_p−t$或者大于$I_p+t$，那么这个点即可判断为角点(n的值可取12或9) 一种快速排除大部分非角点像素的方法就是检查周围1、5、9、13四个位置的像素，如果位置1和9与中心像素P点的灰度差小于给定阈值，则P点不可能是角点，直接排除；否则进一步判断位置5和13与中心像素的灰度差，如果四个像素中至少有3个像素与P点的灰度差超过阈值，则考察邻域圆上16个像素点与中心点的灰度差，如果有至少9个超过给定阈值则认为是角点。 Fast 检测出角点很多都是相邻的，Fast 对其做了非极大值一致处理，对于每个 Fast 交点使用其周围 16 个像素与中心点像素差值的绝对值之和作为得分，对于相邻的像素选择得分最大的点。\n1.2 brief 特征描述符 brief 特征描述的原理是在关键点周围随机选取 N 个点对，对比像素点的像素值大小，根据其像素值的大小得到(0，1)编码，这种二进制编码的表示，可以进行快速的特征匹配和相似度计算。\n1.3 旋转不变性 brief 本身不具有灰度不变性 ，为了保证旋转不变性，ORB 通过关键点邻域内的灰度质心作为特征点的主方向。计算特征描述符时先将主方向旋转为一致，再计算 brief 特征描述符，从而保证旋转不变性。但是旋转后的特征描述符虽然具有了旋转不变性，但是可区分度变弱了。如下图所示，为几种特征描述子的均值分布，横轴为均值与0.5之间的距离，纵轴为相应均值下特征点的统计数量。可以看出，BRIEF描述子所有比特位的均值接近于0.5，且方差很大；方差越大表明可区分性越好。不同特征点的描述子表现出较大的差异性，不易造成无匹配。但steered BRIEF进行了坐标旋转，损失了这个特性，导致可区分性减弱，相关性变强，不利于匹配。为了解决这个问题， ORB 使用了一种基于学习的方法来选择一定数量的随机点对，详情见 图像特征描述子之ORB | Senit_Co。 1.4 特征均匀化 在根据特征点进行位姿求解时，我们希望特征点是比较分散的而不是集中在小块的区域。因为这样可以产生更强的和约束，使得位姿求解更精确。ORB 在进行特征提取时使用了两个 tips 来均匀化特征点。1. 根据图像金字塔的分辨率比例分配每层图像需要提取的特征点数量。2. 使四叉树分裂的方式均匀化特征点，具体方法是对提取所有特征点后对图像进行四叉树分块，如果块中的特征点数量大于1个则进行继续分裂或选取响应值(Fast 交点的得分)最大的特征点，是否分裂取决于是否达到了期望的特征点数量。 1.5 Reference: 图像特征之FAST角点检测 | Senit_Co 图像特征描述子之ORB | Senit_Co Site Unreachable\n2 SIFT ","permalink":"https://zhouwuxiong.github.io/posts/feature_match/","summary":"\u003cp\u003e一个好的特征描述符应该至少保留以下特征：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e旋转不变性\u003c/li\u003e\n\u003cli\u003e尺度不变性\u003c/li\u003e\n\u003cli\u003e光度不敏感\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"1-orb-特征提取\"\u003e1 ORB 特征提取\u003c/h2\u003e\n\u003cp\u003eORB - (Oriented Fast and Rotated BRIEF)算法是基于FAST特征检测与BRIEF特征描述子匹配实现，相比BRIEF算法中依靠随机方式获取而值点对，ORB通过FAST方法，FAST方式寻找候选特征点方式是假设灰度图像像素点A周围的像素存在连续大于或者小于A的灰度值。\u003c/p\u003e\n\u003ch3 id=\"11-fast-角点\"\u003e1.1 Fast 角点\u003c/h3\u003e\n\u003cp\u003e FAST角点定义为：若某像素点与周围邻域足够多的像素点处于不同区域，则该像素可能为角点。考虑灰度图像，即若某像素点的灰度值比周围邻域足够多的像素点的灰度值大或小，则该点可能为角点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于图像中一个像素点$p$，其灰度值为$I_p$\u003c/li\u003e\n\u003cli\u003e以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素(如下图所示)\u003c/li\u003e\n\u003cli\u003e设定一个合适的阈值$t$，如果圆上有n个连续像素点的灰度值小于$I_p−t$或者大于$I_p+t$，那么这个点即可判断为角点(n的值可取12或9)\n \u003cimg alt=\"1-feature_match.png\" loading=\"lazy\" src=\"1-feature_match.png\"\u003e\n一种快速排除大部分非角点像素的方法就是检查周围1、5、9、13四个位置的像素，如果位置1和9与中心像素P点的灰度差小于给定阈值，则P点不可能是角点，直接排除；否则进一步判断位置5和13与中心像素的灰度差，如果四个像素中至少有3个像素与P点的灰度差超过阈值，则考察邻域圆上16个像素点与中心点的灰度差，如果有至少9个超过给定阈值则认为是角点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFast 检测出角点很多都是相邻的，Fast 对其做了非极大值一致处理，对于每个 Fast 交点使用其周围 16 个像素与中心点像素差值的绝对值之和作为得分，对于相邻的像素选择得分最大的点。\u003c/p\u003e\n\u003ch3 id=\"12-brief-特征描述符\"\u003e1.2 brief 特征描述符\u003c/h3\u003e\n\u003cp\u003ebrief 特征描述的原理是在关键点周围随机选取 N 个点对，对比像素点的像素值大小，根据其像素值的大小得到(0，1)编码，这种二进制编码的表示，可以进行快速的特征匹配和相似度计算。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"2-feature_match.png\" loading=\"lazy\" src=\"2-feature_match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"13-旋转不变性\"\u003e1.3 旋转不变性\u003c/h3\u003e\n\u003cp\u003ebrief  本身不具有灰度不变性 ，为了保证旋转不变性，ORB 通过关键点邻域内的\u003ca href=\"https://zhuanlan.zhihu.com/p/481373935\"\u003e灰度质心\u003c/a\u003e作为特征点的主方向。计算特征描述符时先将主方向旋转为一致，再计算 brief 特征描述符，从而保证旋转不变性。但是旋转后的特征描述符虽然具有了旋转不变性，但是可区分度变弱了。如下图所示，为几种特征描述子的均值分布，横轴为均值与0.5之间的距离，纵轴为相应均值下特征点的统计数量。可以看出，BRIEF描述子所有比特位的均值接近于0.5，且方差很大；方差越大表明可区分性越好。不同特征点的描述子表现出较大的差异性，不易造成无匹配。但steered BRIEF进行了坐标旋转，损失了这个特性，导致可区分性减弱，相关性变强，不利于匹配。为了解决这个问题， ORB 使用了一种基于学习的方法来选择一定数量的随机点对，详情见 \u003ca href=\"https://senitco.github.io/2017/07/09/image-feature-orb/\"\u003e图像特征描述子之ORB | Senit_Co\u003c/a\u003e。\n\u003cimg alt=\"3-feature_match.png\" loading=\"lazy\" src=\"3-feature_match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"14-特征均匀化\"\u003e1.4 特征均匀化\u003c/h3\u003e\n\u003cp\u003e在根据特征点进行位姿求解时，我们希望特征点是比较分散的而不是集中在小块的区域。因为这样可以产生更强的和约束，使得位姿求解更精确。ORB 在进行特征提取时使用了两个 tips 来均匀化特征点。1. 根据图像金字塔的分辨率比例分配每层图像需要提取的特征点数量。2. 使四叉树分裂的方式均匀化特征点，具体方法是对提取所有特征点后对图像进行四叉树分块，如果块中的特征点数量大于1个则进行继续分裂或选取响应值(Fast 交点的得分)最大的特征点，是否分裂取决于是否达到了期望的特征点数量。\n\u003cimg alt=\"6-feature_match.png\" loading=\"lazy\" src=\"6-feature_match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"15-reference\"\u003e1.5 Reference:\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://senitco.github.io/2017/06/30/image-feature-fast/\"\u003e图像特征之FAST角点检测 | Senit_Co\u003c/a\u003e\n\u003ca href=\"https://senitco.github.io/2017/07/09/image-feature-orb/\"\u003e图像特征描述子之ORB | Senit_Co\u003c/a\u003e\n\u003ca href=\"https://zhuanlan.zhihu.com/p/481373935\"\u003eSite Unreachable\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"2-sift\"\u003e2 SIFT\u003c/h2\u003e","title":"SLAM 中的基础数学知识"},{"content":"1 旋转的表示 1.1 旋转向量 1.2 旋转矩阵 旋转矩阵有且只有一个实数特征值1； 不考虑单位矩阵，旋转矩阵的实数特征值对应的特征向量即是axis-angle表达式的旋转轴，旋转矩阵的迹与旋转角度相关。 1.3 四元数 球面线性插值（Spherical linear interpolation，slerp) ![[1-SLAM 中的基础数学知识.png]] $$ Slerp(p,q,t) = \\frac{\\sin[(1-t)\\theta] + \\sin(t \\theta q)}{\\sin(\\theta)} $$ 1.4 旋转表示之间的相互转换 四元数转旋转向量 $$ \\begin{cases}{l} \\theta = 2\\arccos s \\\\ [n_x,n_y,n_z]^T = \\frac{v^T}{\\sin{\\frac{\\theta}{2}}} \\end{cases} $$\n旋转$\\theta\\boldsymbol{n}$向量转四元数 $$ \\boldsymbol{q} = [\\cos \\frac{\\theta}{2},\\boldsymbol{n} \\sin \\frac{\\theta}{2}] \\tag{2} $$\n旋转矩阵转旋转向量 $$ \\begin{cases} \\theta = \\arccos(\\frac{tr(\\boldsymbol{R})-1}{2}) \\\\[1ex] n = Rn, \\quad \\text{轴n是R特征值为1的单位特征向量} \\end{cases} \\tag{3} $$\n旋转向量$\\boldsymbol\\omega$转旋转矩阵（罗德里格斯公式） $$ \\boldsymbol{R} = \\cos\\theta \\boldsymbol{I} + (1- \\cos\\theta ) \\boldsymbol {n} \\boldsymbol {n}^T + \\sin\\theta \\boldsymbol {n}^{\\wedge} = exp{(\\boldsymbol{\\omega^{\\wedge}})} \\tag{4} $$ 旋转向量转旋转矩阵本质就是对应李代数的指数映射，李代数的指数映射将旋转向量映射为反对称矩阵\n旋转矩阵转四元数 $$ \\begin{cases} \\boldsymbol\\omega = \\frac{\\sqrt{1 + \\text{trace}(\\boldsymbol{R})}}{2} \\\\[1ex] \\boldsymbol{x} = \\frac{R_{32} - R_{23}}{4w} \\\\[1ex] \\boldsymbol{y} = \\frac{R_{13} - R_{31}}{4w} \\\\[1ex] \\boldsymbol{z} = \\frac{R_{21} - R_{12}}{4w} \\end{cases} \\tag{5} $$ $$ q = sqrt((R_{11} + R_{22} + R_{33} + 1) / 4) * [1, R_{23} - R_{32}, R_{31} - R_{13}, R_{12} - R_{21}] \\tag{6} $$\n四元数转旋转矩阵 $$ \\boldsymbol{R} = \\boldsymbol{v} \\boldsymbol{v}^T + s^2 + \\boldsymbol{I} + 2s \\boldsymbol{v}^{\\wedge} + (\\boldsymbol{v^{\\vee}})^2 \\tag{7} $$\n二维旋转角转旋转矩阵 $$ \\theta = \\begin{bmatrix} \\cos(x) \u0026amp; -sin(x) \\\\ sin(x) \u0026amp; cos(x) \\end{bmatrix} \\tag{8} $$\n欧拉角(roll,pitch,yaw)转旋转矩阵 $$ (roll,pitch,yaw) = (\\alpha,\\beta,\\phi) = \\begin{cases} R_{roll} \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; cos(\\alpha) \u0026amp; -sin(\\alpha) \\\\ 0 \u0026amp; sin(\\alpha) \u0026amp; cos(\\alpha) \\\\ \\end{bmatrix} \\\\[2ex] R_{pitch} \u0026amp;=\u0026amp; \\begin{bmatrix} cos(\\beta) \u0026amp; 0 \u0026amp; sin(\\beta) \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -sin(\\beta) \u0026amp; 0 \u0026amp; cos(\\beta) \\\\ \\end{bmatrix} \\\\[2ex] R_{yaw} \u0026amp;=\u0026amp; \\begin{bmatrix} cos(\\phi) \u0026amp; -sin(\\phi) \u0026amp; 0 \\\\ sin(\\phi) \u0026amp; cos(\\phi) \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\\\[2ex] R_{(\\alpha,\\beta,\\phi)} \u0026amp;=\u0026amp; R_{\\phi}*R_{\\beta}*R_{\\alpha}, \\text{一般采ZYX的顺序进行旋转叠加} \\end{cases} \\tag{9} $$\n计算向量与坐标轴之间的 rpy角 $$ \\begin{cases} roll \u0026amp;=\u0026amp; \\tan(z/y) \\\\ pich \u0026amp;=\u0026amp; \\tan(x/z) \\\\ yaw \u0026amp;=\u0026amp; \\tan(y/x) \\\\ \\end{cases} $$\n四元数转欧拉角（RPY） ![[2-SLAM 中的基础数学知识.png]]\n1.5 区别 四元数表示的旋转，可以更方便的进行插值运算 纯虚四元数的指数映射结果为单位四元数，而单位四元数可以表示空间中的旋转，所以四元数的旋转可以由纯虚四元数的指数映射表示 $$ \\boldsymbol{q} = exp(\\boldsymbol{\\tilde{w}}), \\quad \\boldsymbol{\\tilde{w}}\\text{表示纯虚四元数} $$ 四元数表示旋转时，旋转的角度只有李代数和旋转向量表示的一半，因为使用四元数进行旋转变换时需要进行两次乘法计算 $$\\boldsymbol{p^{\u0026rsquo;}} = \\boldsymbol{q} \\boldsymbol{p} \\boldsymbol{p^{-1}}$$ 其中$\\boldsymbol{p^{\u0026rsquo;}} 和 $\\boldsymbol{p}$ 分别为纯虚四元数表示的3d点坐标。\n李代数更适合表示连续的空间变化，其具有较好的微分性质，在导航和控制问题中更容易处理 一般传感器的测量结果都是角度（例如：IMU），角度可以很方便的转换为四元素，因此其计算非常高效，因此在 IMU 等高频计算场景中一般旋转四元素。但是在视觉 SLAM 中一般用旋转矩阵表示旋转，旋转矩阵可以很方便的通过指数映射转为李代数，并且视觉 SLAM 中需要直接对旋转进行优化，而李代数求导十分方便，所以更适合用李代数。（总结：角度的增量和插值计算用四元数，涉及旋转的导数运算用李代数） 2 常用数学公式 2.1 利群与李代数转换 $$ \\begin{aligned} exp(\\phi^{\\wedge}) \u0026amp;=R \\\\[1ex] \\phi \u0026amp;= log(R)^{\\vee} \\\\[1ex] \\phi^{\\wedge} \u0026amp;= log(R) \\end{aligned} $$\n2.2 叉积交换 $$ \\begin{aligned} a \\times b = - b \\times a \\\\ \\partial\\theta^{\\wedge} \\omega = \\omega^{\\wedge} \\partial\\theta \\end{aligned} $$\n2.3 SO(3) 伴随公式 $$ \\phi^{\\wedge}R = R(R^T\\phi)^{\\wedge} $$\n2.4 指数函数常用性质 $$ \\begin{cases} e^{x} = 1 + x + \\cdots + \\dfrac{x^n}{n!} \\\\[8pt] e^{-ax} = e^{-a} + e^{x} \\\\[8pt] e^{a+b} = e^{a}e^{b} \\end{cases} \\quad\\Rightarrow\\quad \\begin{cases} \\exp(x) = 1 + x \\\\[8pt] \\exp(\\theta + \\Delta\\theta) = \\exp(\\theta)\\exp(\\Delta\\theta) \\end{cases} $$### BCH 近似 BCH 公式关联了李群乘法与李代数加法之间的关系，李群（SO(3)）上乘小量等于李代数（so(3)）上加小量（带雅可比矩阵） $$ \\begin{aligned} exp(\\phi^{\\wedge})exp(\\Delta\\phi^{\\wedge}) \u0026amp; \\approx exp((\\phi+J_r^{-1}\\Delta\\phi)^{\\wedge}) \\\\ exp(\\phi+\\Delta\\phi) \u0026amp; \\approx exp(\\phi^{\\wedge})exp(J_r\\Delta\\phi^{\\wedge}) \\approx exp(J_l\\Delta\\phi^\\wedge)exp(\\phi^{\\wedge}) \\\\ Log(R exp(\\Delta \\phi)) \u0026amp; \\approx Log(R)+ J_r^{-1}(Log(R))\\Delta\\phi^{\\wedge} \\\\ log(\\prod_{k=1}^{j-1}exp(\\Delta\\phi ))^{\\vee} \u0026amp; \\approx \\sum_{k=i}^{j-1}\\Delta\\phi, \\quad \\text{由于 $\\Delta\\phi$ 为小量,所以假定了$J_r=I$} \\end{aligned} $$\nSO(3)上的BCH近似公式 BCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（李代数加法 ⇔ 李群乘法），其线性近似公式广泛应用于各种函数的线性化。 在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成： $$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$ 反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法： $$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge) $$ 其中SO(3)的左雅克比矩阵为 $$ \\begin{aligned} {J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\\\ {J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge} \\end{aligned} $$ 而SO(3)的右雅克比矩阵为 $$ {J}_r({\\phi}) = {J}_l(-{\\phi}) $$\n2.5 旋转求导 $$ \\begin{cases} \\dot{R} = Rw^{\\wedge}, \\quad \\text{该式也称为泊松方程，w为瞬时角速度} \\\\[1ex] \\dot{exp(\\delta\\theta^{\\wedge})} = exp(\\delta\\theta^{\\wedge})exp(\\delta\\dot{\\theta}^{\\wedge}) \\end{cases} $$\n3 几何变换 3.1 平面系数与平面法向量 平面方程 $$ ax+by+cz+d = 0 $$ 平面与各轴的交点： $$ \\begin{cases} P_x : (-\\frac{d}{a},0,0) \\\\ P_y : (0,-\\frac{d}{b},0) \\\\ P_z : (0,0,-\\frac{d}{c}) \\end{cases} $$ 点P(x,y,z)到平面$\\vec{n}$的距离 $$ d_p = \\frac{|\\vec{PP_x} \\vec{n}|}{|\\vec{n}|} $$\n6 KF、EKF、ESKF KF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数 Site Unreachable\nKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵 KF 假设运动方程为: $$ x_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。 $$ x_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T) $$ EKF 假设运动方程为: $$ x_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开： $$ f(x) = f(x_k) + J(x-x_k) $$ 所以下一时刻的$x_{k+1}$ 的分布为 $$ x_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T) $$ 其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。 ESKF ESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\n高斯分布的线性变换 若$x\\sim(\\mu,\\sigma^2)$，则$Ax+b \\sim (A\\mu+b,A\\sigma^2A^T)$ 高斯分布相乘 若$x\\sim(\\mu_0,\\sigma_0^2)$，$y\\sim(\\mu_1,\\sigma_1^2)$，则$x*y \\sim (A\\mu+b,A\\sigma^2A^T)$ ![[1-SLAM 基础.png]]\n4 为什么最小乘的解为最小特征值对应的特征向量 求一个最小二乘问题 $$ min||Ax = b||_2^2, \\quad x \\neq 0 \\quad and \\quad |x| = 1 $$ 首先我们要理解的是求 $Ax=b$ 的解就是求向量b在A矩阵的列空间（以列向量为基地张成的空间）中的像。假设$A=I$那么A的列空间就是欧式空间。如果$A \\neq I$ ,例如： $$ A = \\begin{bmatrix} 2 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$ 那么b在A的列空间中的像的x轴就会被压缩为1/2。这也就是我们常说的特征值表示的是列空间在各个列向量方向上的缩放比例。 接下来我们再看$|x|=1$,很明显在欧式空间中表示为$r=1$的球面构成的集合。但是由于b在A的列空间中的像的各轴坐标会被缩放，所以$|x|=1$在A的列空间中形成的是一个椭球。而求解 $min||Ax = b||_2^2$ 的问题即为在椭球面上找一点，使其到原心的距离最短。根据椭圆的知识我们很容易知道，椭圆上离原心最近的点为短轴与椭圆的交点。短轴则对应的是最小特征向量对应的坐标轴。也即最小二乘的解为最小特征值对应的特征向量。 反之 $max||Ax = b||_2^2$ 的解为最大特征值对应的特征向量\n5 为什么信息矩阵是协方差的逆 协方差表示了不同特征之间的相关性。而根据逆矩阵的伴随矩阵求法可知，的逆矩阵的第 i，j 个元$A_{i,j}$为去掉原矩阵的第i行和第j列之后的剩余元素的行列式与A矩阵行列式的比值。 $$ A^{-1} =\\frac{A^}{|A|},\\quad A^{i,j} 为去掉A{i,j}所在的行和列之后剩余元素的行列式 $$\nAppendix geometry_msgs::Quaternion EulerAngletoQuaternion(double yaw, double pitch, double roll) // yaw (Z), pitch (Y), roll (X) { // Abbreviations for the various angular functions double cy = cos(yaw * 0.5); double sy = sin(yaw * 0.5); double cp = cos(pitch * 0.5); double sp = sin(pitch * 0.5); double cr = cos(roll * 0.5); double sr = sin(roll * 0.5); geometry_msgs::Quaternion q; q.w = cy * cp * cr + sy * sp * sr; q.x = cy * cp * sr - sy * sp * cr; q.y = sy * cp * sr + cy * sp * cr; q.z = sy * cp * cr - cy * sp * sr; return q; } void QuaterniontoEulerAngle(const geometry_msgs::Quaternion \u0026amp;q, double \u0026amp;roll, double \u0026amp;pitch, double \u0026amp;yaw) { // roll (x-axis rotation) double sinr_cosp = +2.0 * (q.w * q.x + q.y * q.z); double cosr_cosp = +1.0 - 2.0 * (q.x * q.x + q.y * q.y); roll = atan2(sinr_cosp, cosr_cosp); // pitch (y-axis rotation) double sinp = +2.0 * (q.w * q.y - q.z * q.x); if (fabs(sinp) \u0026gt;= 1) pitch = copysign(M_PI / 2, sinp); // use 90 degrees if out of range else pitch = asin(sinp); // yaw (z-axis rotation) double siny_cosp = +2.0 * (q.w * q.z + q.x * q.y); double cosy_cosp = +1.0 - 2.0 * (q.y * q.y + q.z * q.z); yaw = atan2(siny_cosp, cosy_cosp); } double angle_normal(double original_ang) { if (original_ang \u0026gt; 3.1415926) original_ang -= piX2; else if (original_ang \u0026lt; -3.1415926) original_ang += piX2; return original_ang; } double angles_weight_mean(double angleA, double weightA, double angleB, double weightB) { //弧度 // double angleA_cal; // double angleB_cal; double mean{}, diff{}; if (angleA * angleB \u0026lt; 0) { if (angleA \u0026lt; 0) { diff = pi + angleA + pi - angleB; if (diff \u0026lt; pi) mean = angleB * weightB + (angleB + diff) * weightA; else mean = angleA * weightA + angleB * weightB; } if (angleB \u0026lt; 0) { diff = pi + angleB + pi - angleA; if (diff \u0026lt; pi) mean = angleA * weightA + (angleA + diff) * weightB; else mean = angleA * weightA + angleB * weightB; } } else { mean = angleA * weightA + angleB * weightB; } return angle_normal(mean); } 平面对齐：\n// 1. 计算两平面的旋转 // 法线叉乘计算两平面的旋转轴 Eigen::Vector3d rot_axis2 = slave_gplane.normal.cross(master_gplane.normal); rot_axis2.normalize(); // 法线点乘计算面的旋转角 double alpha2 = std::acos(slave_gplane.normal.dot(master_gplane.normal)); Eigen::Matrix3d R_ms; // 平面对齐的旋转向量 R_ms = Eigen::AngleAxisd(alpha2, rot_axis2); // 2. 计算两平面的平移 // 平面于z轴的交点 intercept-截距 normal-法线 Eigen::Vector3d slave_intcpt_local( 0, 0, -slave_gplane.intercept / slave_gplane.normal(2)); // 交点旋转到对准点云 Eigen::Vector3d slave_intcpt_master = R_ms * slave_intcpt_local; // 计算平面对齐的平移变量 ？？ 为什么只移动z轴坐标，这样可以将平面重合，平面上的点也能对应吗？ Eigen::Vector3d t_ms(0, 0, t_mp(2) - slave_intcpt_master(2)); ","permalink":"https://zhouwuxiong.github.io/posts/slam-%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","summary":"\u003ch2 id=\"1-旋转的表示\"\u003e1 旋转的表示\u003c/h2\u003e\n\u003ch3 id=\"11-旋转向量\"\u003e1.1 旋转向量\u003c/h3\u003e\n\u003ch3 id=\"12-旋转矩阵\"\u003e1.2 旋转矩阵\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e旋转矩阵有且只有一个实数特征值1；\u003c/li\u003e\n\u003cli\u003e不考虑单位矩阵，旋转矩阵的实数特征值对应的特征向量即是axis-angle表达式的旋转轴，旋转矩阵的迹与旋转角度相关。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"13-四元数\"\u003e1.3 四元数\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://cnblogs.com/21207-iHome/p/6952004.html\"\u003e球面线性插值（Spherical linear interpolation，slerp)\u003c/a\u003e\n![[1-SLAM 中的基础数学知识.png]]\n$$\nSlerp(p,q,t) = \\frac{\\sin[(1-t)\\theta] + \\sin(t \\theta q)}{\\sin(\\theta)}\n$$\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"14-旋转表示之间的相互转换\"\u003e1.4 旋转表示之间的相互转换\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e四元数转旋转向量\n$$\n\\begin{cases}{l}\n\\theta = 2\\arccos s \\\\\n[n_x,n_y,n_z]^T = \\frac{v^T}{\\sin{\\frac{\\theta}{2}}}\n\\end{cases}\n$$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e旋转$\\theta\\boldsymbol{n}$向量转四元数\n$$\n\\boldsymbol{q} = [\\cos \\frac{\\theta}{2},\\boldsymbol{n} \\sin \\frac{\\theta}{2}] \\tag{2}\n$$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e旋转矩阵转旋转向量\n$$\n\\begin{cases}\n\\theta = \\arccos(\\frac{tr(\\boldsymbol{R})-1}{2}) \\\\[1ex]\nn = Rn, \\quad \\text{轴n是R特征值为1的单位特征向量}\n\\end{cases}\n\\tag{3}\n$$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e旋转向量$\\boldsymbol\\omega$转旋转矩阵（\u003cem\u003e罗德里格斯公式\u003c/em\u003e）\n$$\n\\boldsymbol{R} = \\cos\\theta \\boldsymbol{I} + (1- \\cos\\theta ) \\boldsymbol {n} \\boldsymbol {n}^T + \\sin\\theta  \\boldsymbol {n}^{\\wedge} = exp{(\\boldsymbol{\\omega^{\\wedge}})}\n\\tag{4}\n$$\n\u003cem\u003e旋转向量转旋转矩阵本质就是对应李代数的指数映射，李代数的指数映射将旋转向量映射为反对称矩阵\u003c/em\u003e\u003c/p\u003e","title":"SLAM 中的基础数学知识"},{"content":"流程 12414112312324125456787914112233334455668899 obsidian 安装 Enveloppe 1 hugo (静态网站模板生称工具) sudo snap install hugo # disable automatic updates sudo snap refresh --hold hugo hugo new site quickstart hugo version 2 obsidian 安装 Enveloppe link test\n3 Enveloppe 配置 复制 json 文件导入 obsidian-github-publisher-hugo/settings.json at main · miaogaolin/obsidian-github-publisher-hugo · GitHub\n3.1 Enveloppe 配置github fork 网站模板 获取 github token 3.2 目录配置 4 vecel 部署 ","permalink":"https://zhouwuxiong.github.io/posts/obsidian-blog-publish/","summary":"\u003ch1 id=\"流程-12414112312324125456787914112233334455668899\"\u003e流程 12414112312324125456787914112233334455668899\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eobsidian 安装  \u003ccode\u003eEnveloppe\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"1-hugo-静态网站模板生称工具\"\u003e1 hugo (静态网站模板生称工具)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo snap install hugo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# disable automatic updates\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo snap refresh --hold hugo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo new site quickstart \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo version\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2-obsidian-安装--enveloppe\"\u003e2 obsidian 安装  Enveloppe\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"link%20test.md\"\u003elink test\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"3-enveloppe-配置\"\u003e3 Enveloppe 配置\u003c/h2\u003e\n\u003cp\u003e复制 json 文件导入\n\u003ca href=\"https://github.com/miaogaolin/obsidian-github-publisher-hugo/blob/main/settings.json\"\u003eobsidian-github-publisher-hugo/settings.json at main · miaogaolin/obsidian-github-publisher-hugo · GitHub\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"31-enveloppe-配置github\"\u003e3.1 Enveloppe 配置github\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"2-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/2-obsidian%20blog%20publish.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003efork 网站模板\u003c/li\u003e\n\u003cli\u003e获取 github token\n\u003cimg alt=\"1-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/1-obsidian%20blog%20publish.png\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"32-目录配置\"\u003e3.2 目录配置\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"3-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/3-obsidian%20blog%20publish.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"4-vecel-部署\"\u003e4 vecel 部署\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"4-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/4-obsidian%20blog%20publish.png\"\u003e\u003c/p\u003e","title":""}]