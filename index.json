[{"content":"1 单目初始化 单目初始化分主要为4步：\n特征匹配 8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果 利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 Initializer::CheckRT。 根据计算重投影误差和视差选取最优的解。 Tips1 由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。\nTips2 F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。\n2 回环检测 2.1 回环候选帧选取 ORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。\n图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。 组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。 Step 1 : 相似图像检测 ORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。\nORB_SLAM 中的单词数量阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix KeyFrameDatabase::DetectLoopCandidates\nStep 2 : 组连续检测 组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示： 组: 与当前帧具有一级共视关系的关键帧集合为一组 组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。\n2.2 sim3 位姿求解 Sim3Solver::ComputeSim3 sim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(\u0026gt;20)(ORBmatcher::SearchByBoW)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 Sim3Solver::CheckInliers)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 ORBmatcher::SearchBySim3，其具体操作时使用 sim3 位姿将地图点\nORBmatcher::SearchByBoW 和 ORBmatcher::SearchBySim3 在都是用特征描述符之见的距离进行匹配特征点的筛选，但是 ORBℹimatcher::SearchByBoW 使用更严格的阈值ORBmatcher::TH_LOW = 50 而ORBmatcher::SearchBySim3 使的阈值更宽松，ORBmatcher::TH_HIGH = 100。前者是为了尽量防止误匹配，后则则是为了增加约束提高求解精度，同时避免光照变化等导致特征点的匹配得分较低，而错过一些可用的特征点对，例如：车辆从相反的方向驶过同一各地方，由于提取的特征点是镜像的，所以可能导致匹配得分偏低。\n2.3 当前帧局部地图更新 在求得当前帧的回环位姿后，需要建立当前帧局部和回环帧局部地图之间的共视关系，主要包括：\n更新当前帧与回环帧之间的共视关系，因为之前通过 ORBmatcher::SearchBySim3 新增了一些当前帧和回环帧之间的匹配点，这一步主要是将匹配特征点与地图点相关联。 将回环位姿与更踪位姿的偏移量拓展到当前帧局部地图中的关键帧和地图点 将回环帧局部地图中的地图点投影当前帧的局部地图中，建立匹配关系，同时更新局部地图之间的连接关系``` 1. ![11-ORB_SLAM.png](11-ORB_SLAM.png) 2. 只获取当前帧与回环地图之间的连接关系，然后进行本质图优化。也就是联合当前帧的局部地图和回环帧的局部地图进行位姿优化 ![10-ORB_SLAM.png](10-ORB_SLAM.png) 3. 将回环帧局部地图中的地图点投影到当前帧局部地图，根据投影点匹配关系，更新局部地图帧间的共视 ### 2.4 回环位姿优化 g2o 优化最重要的是确定待优化变量(顶点)和边约束(比较确定的观测值，尽量保证这些值不边)。所以在构建图优化时，我们需要做的只有两件事，确定待优化变量、固定变量、和有哪些可用的观测约束 #### 2.4.1 本质图优化 `Optimizer::OptimizeEssentialGraph` 本质图优化的目标是在检测到闭环后，通过优化一组稀疏的关键帧位姿（Sim3位姿，包含尺度因子）来校正整个地图的累积误差。它不同于全局BA（优化所有关键帧位姿和地图点），而是只优化关键帧位姿，且仅使用共视图中的强连接边（生成树、强共视边、闭环边）来构建图结构。这样可以在保证精度的同时大幅减少计算量，实现实时优化。 顶点(待优化变量): 地图中的所有关键帧，优先使用回环优化后的sim3位姿，固定回环帧的位姿 边 (约束，一般为比较可信的相对位姿): 1. 回环约束，优先回环位姿作为观测 2. 生成树边约束，优先使用跟踪位姿作为观测 3. 历史回环边约束，优先使用历史位姿作为观测 4. 共识程度较高的边 (\u0026gt;100)，优先使用历史关键帧作为观测 残差 相对位姿残差 \u0026gt; 在构见本质图优化时，没有对关键帧使用边边缘化策略，并且信息矩阵设置为单位矩阵 优化完成之后，对关键帧进行词读调整，调整地图点位姿，具体做法就是使用关键帧的旧位姿将3d点变换到相机坐标后，用优化后的关键帧位姿将相机坐标系下的地图点变换到世界坐标系下。 #### 2.4.2 全局 BA `Optimizer::GlobalBundleAdjustemnt` 顶点: - 所有关键帧，0 号帧位姿被固定 - 所有地图点 边: - 地图点的重投影像素坐标作为边，但是会根据特征点在图像金子塔上层数进行加权，图层越高，可信度越差。 - 残差: - 地图点的重投影误差，特征点作为观测 \u0026gt; BA 优化时使用了 huber 核函数抑制异常点导致的大的残差值，例如： 动态特征点 \u0026gt; 根据特征点在不同的金子塔层数，设置协方差矩阵，低 0 层的协方差为 $I$ , 层数越高协方差矩阵的值越小，这是一种特定点进行加权的方式。 ## 3 局部地图优化 ## 4 ## 5 imu 初始化 在IMU初始化阶段会进行三类优化：Visual-Only、Inertial-Only和Visual-Inertial联合 ## 6 imu 初始化 ## 7 视觉贯导联合初始化 ## 8 Appendix ```cpp /** * @brief 在闭环检测中找到与该关键帧可能闭环的关键帧（注意不和当前帧连接） * Step 1：找出和当前帧具有公共单词的所有关键帧，不包括与当前帧连接的关键帧 * Step 2：只和具有共同单词较多的（最大数目的80%以上）关键帧进行相似度计算 * Step 3：计算上述候选帧对应的共视关键帧组的总得分，只取最高组得分75%以上的组 * Step 4：得到上述组中分数最高的关键帧作为闭环候选关键帧 * @param[in] pKF 需要闭环检测的关键帧 * @param[in] minScore 候选闭环关键帧帧和当前关键帧的BoW相似度至少要大于minScore * @return vector\u0026lt;KeyFrame*\u0026gt; 闭环候选关键帧 */ vector\u0026lt;KeyFrame*\u0026gt; KeyFrameDatabase::DetectLoopCandidates(KeyFrame* pKF, float minScore) { // 取出与当前关键帧相连（\u0026gt;15个共视地图点）的所有关键帧，这些相连关键帧都是局部相连，在闭环检测的时候将被剔除 // 相连关键帧定义见 KeyFrame::UpdateConnections() set\u0026lt;KeyFrame*\u0026gt; spConnectedKeyFrames = pKF-\u0026gt;GetConnectedKeyFrames(); // 用于保存可能与当前关键帧形成闭环的候选帧（只要有相同的word，且不属于局部相连（共视）帧） list\u0026lt;KeyFrame*\u0026gt; lKFsSharingWords; // Step1 根据 BoW 的逆索引查找与当前关键帧有公共单词的帧 { unique_lock\u0026lt;mutex\u0026gt; lock(mMutex); // words是检测图像是否匹配的枢纽，遍历该pKF的每一个word // mBowVec 内部实际存储的是std::map\u0026lt;WordId, WordValue\u0026gt; // WordId 和 WordValue 表示Word在叶子中的id 和权重 for(DBoW2::BowVector::const_iterator vit=pKF-\u0026gt;mBowVec.begin(), vend=pKF-\u0026gt;mBowVec.end(); vit != vend; vit++) { // 提取所有包含该word的KeyFrame list\u0026lt;KeyFrame*\u0026gt; \u0026amp;lKFs = mvInvertedFile[vit-\u0026gt;first]; // 然后对这些关键帧展开遍历 for(list\u0026lt;KeyFrame*\u0026gt;::iterator lit=lKFs.begin(), lend= lKFs.end(); lit!=lend; lit++) { KeyFrame* pKFi=*lit; if(pKFi-\u0026gt;mnLoopQuery!=pKF-\u0026gt;mnId) { // 还没有标记为pKF的闭环候选帧 pKFi-\u0026gt;mnLoopWords=0; // 和当前关键帧共视的话不作为闭环候选帧 if(!spConnectedKeyFrames.count(pKFi)) { // 没有共视就标记作为闭环候选关键帧，放到lKFsSharingWords里 pKFi-\u0026gt;mnLoopQuery=pKF-\u0026gt;mnId; lKFsSharingWords.push_back(pKFi); } } pKFi-\u0026gt;mnLoopWords++;// 记录pKFi与pKF具有相同word的个数 } } } // 如果没有关键帧和这个关键帧具有相同的单词,那么就返回空 if(lKFsSharingWords.empty()) return vector\u0026lt;KeyFrame*\u0026gt;(); list\u0026lt;pair\u0026lt;float,KeyFrame*\u0026gt; \u0026gt; lScoreAndMatch; // Only compare against those keyframes that share enough words // Step 2：统计上述所有闭环候选帧中与当前帧具有共同单词最多的单词数，用来决定相对阈值 int maxCommonWords=0; for(list\u0026lt;KeyFrame*\u0026gt;::iterator lit=lKFsSharingWords.begin(), lend= lKFsSharingWords.end(); lit!=lend; lit++) { if((*lit)-\u0026gt;mnLoopWords\u0026gt;maxCommonWords) maxCommonWords=(*lit)-\u0026gt;mnLoopWords; } // 确定最小公共单词数为最大公共单词数目的0.8倍 int minCommonWords = maxCommonWords*0.8f; int nscores=0; // Compute similarity score. Retain the matches whose score is higher than minScore // Step 3：遍历上述所有闭环候选帧，挑选出共有单词数大于 minCommonWords 且单词匹配度大于 minScore 存入 lScoreAndMatch for(list\u0026lt;KeyFrame*\u0026gt;::iterator lit=lKFsSharingWords.begin(), lend= lKFsSharingWords.end(); lit!=lend; lit++) { KeyFrame* pKFi = *lit; if(pKFi-\u0026gt;mnLoopWords\u0026gt; minCommonWords ) { nscores++; float si = mpVoc-\u0026gt;score(pKF-\u0026gt;mBowVec,pKFi-\u0026gt;mBowVec); pKFi-\u0026gt;mLoopScore = si; if(si\u0026gt;=minScore) lScoreAndMatch.push_back(make_pair(si,pKFi)); } } if(lScoreAndMatch.empty()) return vector\u0026lt;KeyFrame*\u0026gt;(); list\u0026lt;pair\u0026lt;float,KeyFrame*\u0026gt; \u0026gt; lAccScoreAndMatch; float bestAccScore = minScore; // Step 4：计算当前帧与候选帧的共视帧之间的相似度累计值，从中选取累计相似度最高的帧，这样可以保证在后续进行位姿求解时有足够的共视约束 for(list\u0026lt;pair\u0026lt;float,KeyFrame*\u0026gt; \u0026gt;::iterator it=lScoreAndMatch.begin(), itend=lScoreAndMatch.end(); it!=itend; it++) { KeyFrame* pKFi = it-\u0026gt;second; vector\u0026lt;KeyFrame*\u0026gt; vpNeighs = pKFi-\u0026gt;GetBestCovisibilityKeyFrames(10); float bestScore = it-\u0026gt;first; // 该组最高分数 float accScore = it-\u0026gt;first; // 该组累计得分 KeyFrame* pBestKF = pKFi; // 该组最高分数对应的关键帧 // 遍历共视关键帧，累计得分 for(vector\u0026lt;KeyFrame*\u0026gt;::iterator vit=vpNeighs.begin(), vend=vpNeighs.end(); vit!=vend; vit++) { KeyFrame* pKF2 = *vit; // 只有pKF2也在闭环候选帧中，且公共单词数超过最小要求，才能贡献分数 if(pKF2-\u0026gt;mnLoopQuery==pKF-\u0026gt;mnId \u0026amp;\u0026amp; pKF2-\u0026gt;mnLoopWords\u0026gt; minCommonWords ) { accScore+=pKF2-\u0026gt;mLoopScore; // 统计得到组里分数最高的关键帧 if(pKF2-\u0026gt;mLoopScore\u0026gt;bestScore) { pBestKF=pKF2; bestScore = pKF2-\u0026gt;mLoopScore; } } } lAccScoreAndMatch.push_back(make_pair(accScore,pBestKF)); // 记录所有组中组得分最高的组，用于确定相对阈值 if(accScore\u0026gt;bestAccScore) bestAccScore=accScore; } // Return all those keyframes with a score higher than 0.75*bestScore // 所有组中最高得分的0.75倍，作为最低阈值 float minScoreToRetain = 0.75f*bestAccScore; set\u0026lt;KeyFrame*\u0026gt; spAlreadyAddedKF; vector\u0026lt;KeyFrame*\u0026gt; vpLoopCandidates; vpLoopCandidates.reserve(lAccScoreAndMatch.size()); // Step 5：只取组得分大于阈值的组，得到组中分数最高的关键帧们作为闭环候选关键帧 for(list\u0026lt;pair\u0026lt;float,KeyFrame*\u0026gt; \u0026gt;::iterator it=lAccScoreAndMatch.begin(), itend=lAccScoreAndMatch.end(); it!=itend; it++) { if(it-\u0026gt;first\u0026gt;minScoreToRetain) { KeyFrame* pKFi = it-\u0026gt;second; // spAlreadyAddedKF 是为了防止重复添加 if(!spAlreadyAddedKF.count(pKFi)) { vpLoopCandidates.push_back(pKFi); spAlreadyAddedKF.insert(pKFi); } } } return vpLoopCandidates; } void Sim3Solver::ComputeSim3(cv::Mat \u0026amp;P1, cv::Mat \u0026amp;P2) { // Sim3计算过程参考论文: // Horn 1987, Closed-form solution of absolute orientataion using unit quaternions // Step 1: 定义3D点质心及去质心后的点 // O1和O2分别为P1和P2矩阵中3D点的质心 // Pr1和Pr2为减去质心后的3D点 cv::Mat Pr1(P1.size(),P1.type()); // Relative coordinates to centroid (set 1) cv::Mat Pr2(P2.size(),P2.type()); // Relative coordinates to centroid (set 2) cv::Mat O1(3,1,Pr1.type()); // Centroid of P1 cv::Mat O2(3,1,Pr2.type()); // Centroid of P2 ComputeCentroid(P1,Pr1,O1); ComputeCentroid(P2,Pr2,O2); // Step 2: 计算论文中三维点数目n\u0026gt;3的 M 矩阵。这里只使用了3个点 // Pr2 对应论文中 r_l,i\u0026#39;，Pr1 对应论文中 r_r,i\u0026#39;,计算的是P2到P1的Sim3，论文中是left 到 right的Sim3 cv::Mat M = Pr2*Pr1.t(); // Step 3: 计算论文中的 N 矩阵 double N11, N12, N13, N14, N22, N23, N24, N33, N34, N44; cv::Mat N(4,4,P1.type()); N11 = M.at\u0026lt;float\u0026gt;(0,0)+M.at\u0026lt;float\u0026gt;(1,1)+M.at\u0026lt;float\u0026gt;(2,2); // Sxx+Syy+Szz N12 = M.at\u0026lt;float\u0026gt;(1,2)-M.at\u0026lt;float\u0026gt;(2,1); // Syz-Szy N13 = M.at\u0026lt;float\u0026gt;(2,0)-M.at\u0026lt;float\u0026gt;(0,2); // Szx-Sxz N14 = M.at\u0026lt;float\u0026gt;(0,1)-M.at\u0026lt;float\u0026gt;(1,0); // ... N22 = M.at\u0026lt;float\u0026gt;(0,0)-M.at\u0026lt;float\u0026gt;(1,1)-M.at\u0026lt;float\u0026gt;(2,2); N23 = M.at\u0026lt;float\u0026gt;(0,1)+M.at\u0026lt;float\u0026gt;(1,0); N24 = M.at\u0026lt;float\u0026gt;(2,0)+M.at\u0026lt;float\u0026gt;(0,2); N33 = -M.at\u0026lt;float\u0026gt;(0,0)+M.at\u0026lt;float\u0026gt;(1,1)-M.at\u0026lt;float\u0026gt;(2,2); N34 = M.at\u0026lt;float\u0026gt;(1,2)+M.at\u0026lt;float\u0026gt;(2,1); N44 = -M.at\u0026lt;float\u0026gt;(0,0)-M.at\u0026lt;float\u0026gt;(1,1)+M.at\u0026lt;float\u0026gt;(2,2); N = (cv::Mat_\u0026lt;float\u0026gt;(4,4) \u0026lt;\u0026lt; N11, N12, N13, N14, N12, N22, N23, N24, N13, N23, N33, N34, N14, N24, N34, N44); // Step 4: 特征值分解求最大特征值对应的特征向量，就是我们要求的旋转四元数 cv::Mat eval, evec; // val vec // 特征值默认是从大到小排列，所以evec[0] 是最大值 cv::eigen(N,eval,evec); // N 矩阵最大特征值（第一个特征值）对应特征向量就是要求的四元数（q0 q1 q2 q3），其中q0 是实部 // 将(q1 q2 q3)放入vec（四元数的虚部） cv::Mat vec(1,3,evec.type()); (evec.row(0).colRange(1,4)).copyTo(vec); //extract imaginary part of the quaternion (sin*axis) // Rotation angle. sin is the norm of the imaginary part, cos is the real part // 四元数虚部模长 norm(vec)=sin(theta/2), 四元数实部 evec.at\u0026lt;float\u0026gt;(0,0)=q0=cos(theta/2) // 这一步的ang实际是theta/2，theta 是旋转向量中旋转角度 // ? 这里也可以用 arccos(q0)=angle/2 得到旋转角吧 double ang=atan2(norm(vec),evec.at\u0026lt;float\u0026gt;(0,0)); // vec/norm(vec)归一化得到归一化后的旋转向量,然后乘上角度得到包含了旋转轴和旋转角信息的旋转向量vec vec = 2*ang*vec/norm(vec); //Angle-axis x. quaternion angle is the half mR12i.create(3,3,P1.type()); // 旋转向量（轴角）转换为旋转矩阵 cv::Rodrigues(vec,mR12i); // computes the rotation matrix from angle-axis // Step 5: Rotate set 2 // 利用刚计算出来的旋转将三维点旋转到同一个坐标系，P3对应论文里的 r_l,i\u0026#39;, Pr1 对应论文里的r_r,i\u0026#39; cv::Mat P3 = mR12i*Pr2; // Step 6: 计算尺度因子 Scale if(!mbFixScale) { // 论文中有2个求尺度方法。一个是p632右中的位置，考虑了尺度的对称性 // 代码里实际使用的是另一种方法，这个公式对应着论文中p632左中位置的那个 // Pr1 对应论文里的r_r,i\u0026#39;,P3对应论文里的 r_l,i\u0026#39;,(经过坐标系转换的Pr2), n=3, 剩下的就和论文中都一样了 double nom = Pr1.dot(P3); // 准备计算分母 cv::Mat aux_P3(P3.size(),P3.type()); aux_P3=P3; // 先得到平方 cv::pow(P3,2,aux_P3); double den = 0; // 然后再累加 for(int i=0; i\u0026lt;aux_P3.rows; i++) { for(int j=0; j\u0026lt;aux_P3.cols; j++) { den+=aux_P3.at\u0026lt;float\u0026gt;(i,j); } } ms12i = nom/den; } else ms12i = 1.0f; // Step 7: 计算平移Translation mt12i.create(1,3,P1.type()); // 论文中平移公式 mt12i = O1 - ms12i*mR12i*O2; // Step 8: 计算双向变换矩阵，目的是在后面的检查的过程中能够进行双向的投影操作 // Step 8.1 用尺度，旋转，平移构建变换矩阵 T12 mT12i = cv::Mat::eye(4,4,P1.type()); cv::Mat sR = ms12i*mR12i; // |sR t| // mT12i = | 0 1| sR.copyTo(mT12i.rowRange(0,3).colRange(0,3)); mt12i.copyTo(mT12i.rowRange(0,3).col(3)); // Step 8.2 T21 mT21i = cv::Mat::eye(4,4,P1.type()); cv::Mat sRinv = (1.0/ms12i)*mR12i.t(); sRinv.copyTo(mT21i.rowRange(0,3).colRange(0,3)); cv::Mat tinv = -sRinv*mt12i; tinv.copyTo(mT21i.rowRange(0,3).col(3)); } /** * @brief 用位姿来对特征匹配点三角化，从中筛选中合格的三维点 * * @param[in] R 旋转矩阵R * @param[in] t 平移矩阵t * @param[in] vKeys1 参考帧特征点 * @param[in] vKeys2 当前帧特征点 * @param[in] vMatches12 两帧特征点的匹配关系 * @param[in] vbMatchesInliers 特征点对内点标记 * @param[in] K 相机内参矩阵 * @param[in \u0026amp; out] vP3D 三角化测量之后的特征点的空间坐标 * @param[in] th2 重投影误差的阈值 * @param[in \u0026amp; out] vbGood 标记成功三角化点？ * @param[in \u0026amp; out] parallax 计算出来的比较大的视差角（注意不是最大，具体看后面代码） * @return int */ int Initializer::CheckRT(const cv::Mat \u0026amp;R, const cv::Mat \u0026amp;t, const vector\u0026lt;cv::KeyPoint\u0026gt; \u0026amp;vKeys1, const vector\u0026lt;cv::KeyPoint\u0026gt; \u0026amp;vKeys2, const vector\u0026lt;Match\u0026gt; \u0026amp;vMatches12, vector\u0026lt;bool\u0026gt; \u0026amp;vbMatchesInliers, const cv::Mat \u0026amp;K, vector\u0026lt;cv::Point3f\u0026gt; \u0026amp;vP3D, float th2, vector\u0026lt;bool\u0026gt; \u0026amp;vbGood, float \u0026amp;parallax) { // 对给出的特征点对及其R t , 通过三角化检查解的有效性，也称为 cheirality check // Calibration parameters //从相机内参数矩阵获取相机的校正参数 const float fx = K.at\u0026lt;float\u0026gt;(0,0); const float fy = K.at\u0026lt;float\u0026gt;(1,1); const float cx = K.at\u0026lt;float\u0026gt;(0,2); const float cy = K.at\u0026lt;float\u0026gt;(1,2); //特征点是否是good点的标记，这里的特征点指的是参考帧中的特征点 vbGood = vector\u0026lt;bool\u0026gt;(vKeys1.size(),false); //重设存储空间坐标的点的大小 vP3D.resize(vKeys1.size()); //存储计算出来的每对特征点的视差 vector\u0026lt;float\u0026gt; vCosParallax; vCosParallax.reserve(vKeys1.size()); // Camera 1 Projection Matrix K[I|0] // Step 1：计算相机的投影矩阵 // 投影矩阵P是一个 3x4 的矩阵，可以将空间中的一个点投影到平面上，获得其平面坐标，这里均指的是齐次坐标。 // 对于第一个相机是 P1=K*[I|0] // 以第一个相机的光心作为世界坐标系, 定义相机的投影矩阵 cv::Mat P1(3,4,\t//矩阵的大小是3x4 CV_32F,\t//数据类型是浮点数 cv::Scalar(0));\t//初始的数值是0 //将整个K矩阵拷贝到P1矩阵的左侧3x3矩阵，因为 K*I = K K.copyTo(P1.rowRange(0,3).colRange(0,3)); // 第一个相机的光心设置为世界坐标系下的原点 cv::Mat O1 = cv::Mat::zeros(3,1,CV_32F); // Camera 2 Projection Matrix K[R|t] // 计算第二个相机的投影矩阵 P2=K*[R|t] cv::Mat P2(3,4,CV_32F); R.copyTo(P2.rowRange(0,3).colRange(0,3)); t.copyTo(P2.rowRange(0,3).col(3)); //最终结果是K*[R|t] P2 = K*P2; // 第二个相机的光心在世界坐标系下的坐标 cv::Mat O2 = -R.t()*t; //在遍历开始前，先将good点计数设置为0 int nGood=0; // 开始遍历所有的特征点对 for(size_t i=0, iend=vMatches12.size();i\u0026lt;iend;i++) { // 跳过outliers if(!vbMatchesInliers[i]) continue; // Step 2 获取特征点对，调用Triangulate() 函数进行三角化，得到三角化测量之后的3D点坐标 // kp1和kp2是匹配好的有效特征点 const cv::KeyPoint \u0026amp;kp1 = vKeys1[vMatches12[i].first]; const cv::KeyPoint \u0026amp;kp2 = vKeys2[vMatches12[i].second]; //存储三维点的的坐标 cv::Mat p3dC1; // 利用三角法恢复三维点p3dC1 Triangulate(kp1,kp2,\t//特征点 P1,P2,\t//投影矩阵 p3dC1);\t//输出，三角化测量之后特征点的空间坐标\t// Step 3 第一关：检查三角化的三维点坐标是否合法（非无穷值） // 只要三角测量的结果中有一个是无穷大的就说明三角化失败，跳过对当前点的处理，进行下一对特征点的遍历 if(!isfinite(p3dC1.at\u0026lt;float\u0026gt;(0)) || !isfinite(p3dC1.at\u0026lt;float\u0026gt;(1)) || !isfinite(p3dC1.at\u0026lt;float\u0026gt;(2))) { //其实这里就算是不这样写也没问题，因为默认的匹配点对就不是good点 vbGood[vMatches12[i].first]=false; //继续对下一对匹配点的处理 continue; } // Check parallax // Step 4 第二关：通过三维点深度值正负、两相机光心视差角大小来检查是否合法 //得到向量PO1 cv::Mat normal1 = p3dC1 - O1; //求取模长，其实就是距离 float dist1 = cv::norm(normal1); //同理构造向量PO2 cv::Mat normal2 = p3dC1 - O2; //求模长 float dist2 = cv::norm(normal2); //根据公式：a.*b=|a||b|cos_theta 可以推导出来下面的式子 float cosParallax = normal1.dot(normal2)/(dist1*dist2); // Check depth in front of first camera (only if enough parallax, as \u0026#34;infinite\u0026#34; points can easily go to negative depth) // 如果深度值为负值，为非法三维点跳过该匹配点对 // ?视差比较小时，重投影误差比较大。这里0.99998 对应的角度为0.36°,这里不应该是 cosParallax\u0026gt;0.99998 吗？ // ?因为后面判断vbGood 点时的条件也是 cosParallax\u0026lt;0.99998 // !可能导致初始化不稳定 if(p3dC1.at\u0026lt;float\u0026gt;(2)\u0026lt;=0 \u0026amp;\u0026amp; cosParallax\u0026lt;0.99998) continue; // Check depth in front of second camera (only if enough parallax, as \u0026#34;infinite\u0026#34; points can easily go to negative depth) // 讲空间点p3dC1变换到第2个相机坐标系下变为p3dC2 cv::Mat p3dC2 = R*p3dC1+t;\t//判断过程和上面的相同 if(p3dC2.at\u0026lt;float\u0026gt;(2)\u0026lt;=0 \u0026amp;\u0026amp; cosParallax\u0026lt;0.99998) continue; // Step 5 第三关：计算空间点在参考帧和当前帧上的重投影误差，如果大于阈值则舍弃 // Check reprojection error in first image // 计算3D点在第一个图像上的投影误差 //投影到参考帧图像上的点的坐标x,y float im1x, im1y; //这个使能空间点的z坐标的倒数 float invZ1 = 1.0/p3dC1.at\u0026lt;float\u0026gt;(2); //投影到参考帧图像上。因为参考帧下的相机坐标系和世界坐标系重合，因此这里就直接进行投影就可以了 im1x = fx*p3dC1.at\u0026lt;float\u0026gt;(0)*invZ1+cx; im1y = fy*p3dC1.at\u0026lt;float\u0026gt;(1)*invZ1+cy; //参考帧上的重投影误差，这个的确就是按照定义来的 float squareError1 = (im1x-kp1.pt.x)*(im1x-kp1.pt.x)+(im1y-kp1.pt.y)*(im1y-kp1.pt.y); // 重投影误差太大，跳过淘汰 if(squareError1\u0026gt;th2) continue; // Check reprojection error in second image // 计算3D点在第二个图像上的投影误差，计算过程和第一个图像类似 float im2x, im2y; // 注意这里的p3dC2已经是第二个相机坐标系下的三维点了 float invZ2 = 1.0/p3dC2.at\u0026lt;float\u0026gt;(2); im2x = fx*p3dC2.at\u0026lt;float\u0026gt;(0)*invZ2+cx; im2y = fy*p3dC2.at\u0026lt;float\u0026gt;(1)*invZ2+cy; // 计算重投影误差 float squareError2 = (im2x-kp2.pt.x)*(im2x-kp2.pt.x)+(im2y-kp2.pt.y)*(im2y-kp2.pt.y); // 重投影误差太大，跳过淘汰 if(squareError2\u0026gt;th2) continue; // Step 6 统计经过检验的3D点个数，记录3D点视差角 // 如果运行到这里就说明当前遍历的这个特征点对靠谱，经过了重重检验，说明是一个合格的点，称之为good点 vCosParallax.push_back(cosParallax); //存储这个三角化测量后的3D点在世界坐标系下的坐标 vP3D[vMatches12[i].first] = cv::Point3f(p3dC1.at\u0026lt;float\u0026gt;(0),p3dC1.at\u0026lt;float\u0026gt;(1),p3dC1.at\u0026lt;float\u0026gt;(2)); //good点计数++ nGood++; //判断视差角，只有视差角稍稍大一丢丢的才会给打good点标记 //? bug 我觉得这个写的位置不太对。你的good点计数都++了然后才判断，不是会让good点标志和good点计数不一样吗 if(cosParallax\u0026lt;0.99998) vbGood[vMatches12[i].first]=true; } // Step 7 得到3D点中较小的视差角，并且转换成为角度制表示 if(nGood\u0026gt;0) { // 从小到大排序，注意vCosParallax值越大，视差越小 sort(vCosParallax.begin(),vCosParallax.end()); // !排序后并没有取最小的视差角，而是取一个较小的视差角 // 作者的做法：如果经过检验过后的有效3D点小于50个，那么就取最后那个最小的视差角(cos值最大) // 如果大于50个，就取排名第50个的较小的视差角即可，为了避免3D点太多时出现太小的视差角 size_t idx = min(50,int(vCosParallax.size()-1)); //将这个选中的角弧度制转换为角度制 parallax = acos(vCosParallax[idx])*180/CV_PI; } else //如果没有good点那么这个就直接设置为0了 parallax=0; //返回good点计数 return nGood; } ","permalink":"https://zhouwuxiong.github.io/posts/orb_slam2/","summary":"\u003ch2 id=\"1-单目初始化\"\u003e1 单目初始化\u003c/h2\u003e\n\u003cp\u003e单目初始化分主要为4步：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e特征匹配\u003c/li\u003e\n\u003cli\u003e8点法多轮 ransac 求解，根据投影点到极线的距离选取最优结果\u003c/li\u003e\n\u003cli\u003e利用求解的位姿结果进行地图点三角化。然后去除深度为负、无限远点(距离太远估计的深度值不准确)、视差太小、重投影误差的点 \u003ccode\u003eInitializer::CheckRT\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e根据计算重投影误差和视差选取最优的解。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTips1  由于单初始化确定的相对位姿，没有一个确定的坐标系，所以两帧之间运动的正方向是不确定的，对于 F 矩阵由于R和t的方向运动方向不确定，所以其有4组合的解，但是对于 H 矩阵，因为基于平面投影转换，由于平面法向量的正负不确定，导致 H 矩阵的深度方向也是不确定的，所以其会有 8 种可能的解。ORB_SLAM 会根据重投影的内点数量选择最合适的组合。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTips2  F 矩阵需要考虑纯旋转问题，因为纯旋转时无法准确的求出t，ORB_SLAM 使用所有3d点视差的中值来判断纯旋转，这样可以避免误选到动态特征点。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"2-回环检测\"\u003e2 回环检测\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"12-ORB_SLAM.png\" loading=\"lazy\" src=\"12-ORB_SLAM.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"21-回环候选帧选取\"\u003e2.1 回环候选帧选取\u003c/h3\u003e\n\u003cp\u003eORB_SLAM 的回环候选帧选取主要分为图像相似度检测和组连续检测。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e图像相似度检测，当前帧与候选帧之间的公共单词数量和相似度得分要高于局部地图的最低得分。\u003c/li\u003e\n\u003cli\u003e组连续检测，需要有连续3帧的当前帧都和同一个组的候选帧产生回环匹配。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eStep 1 : 相似图像检测\nORB_SLAM2 在进行相似图像检测时有两个判断的标准，一个单帧的相似性，另一个邻域多帧的相似性。单帧的相似性主要是根据图像帧之间的公共单词数量和相似度得分进行判断。邻域多帧相似性是通过累计当前帧与候选帧的共视帧之间所有相似度得分来进行判断，这么是为了保证选取的候选帧与当前帧之间有足够的共视约束，有利于后续以候选帧构建局部地图来求解当前帧的回环位姿。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eORB_SLAM 中的\u003cem\u003e单词数量\u003c/em\u003e阈值为最大公共单词数量 * 0.8，BoW 得分阈值为当前帧的共视关键帧中最低的相似度得分，邻域多帧相似性得分是累计得分的最大值 * 0.75 ， 详情建 Appendix  KeyFrameDatabase::DetectLoopCandidates\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eStep 2 : 组连续检测\n组连续检测是为了防止触发误回环，他的原理是在更踪过程中的连续多帧都检测到了回环候选帧，并且这些回环候选这年都是在一个连续相邻的区域。一个有效的组连续检测结果如下图所示：\n\u003cimg alt=\"4-ORB_SLAM.png\" loading=\"lazy\" src=\"4-ORB_SLAM.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e组: 与当前帧具有一级共视关系的关键帧集合为一组\n组连续: 关键帧之间不是之间的共视关系，但是有共同的共视帧称为组连续，如图中 1和 2。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"22-sim3-位姿求解--sim3solvercomputesim3\"\u003e2.2 sim3 位姿求解 \u003ccode\u003e Sim3Solver::ComputeSim3\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003esim3 几何验证主要是为了避免对纹理相似场景的误判，首先根据 BoW 在回环候选帧与当前前帧之间进行查找匹配特征点，如果匹配特征点足够(\u0026gt;20)(\u003ccode\u003eORBmatcher::SearchByBoW\u003c/code\u003e)，那么进行 sim3 位姿求解。对匹配关键帧对应的 3d 点分别使用旧位姿和 sim3 位姿进行反投影，统计允许误差范围内的内点数量(见 \u003ccode\u003eSim3Solver::CheckInliers\u003c/code\u003e)，如果内点数达到了阈值则认为求解成功。 使用 sim3 位姿进行反投影查找更多的特征点 \u003ccode\u003eORBmatcher::SearchBySim3\u003c/code\u003e，其具体操作时使用 sim3 位姿将地图点\u003c/p\u003e","title":"ORB_SLAM2 核心代码解析"},{"content":"1 旋转的表示 1.1 旋转向量 1.2 旋转矩阵 旋转矩阵有且只有一个实数特征值1； 不考虑单位矩阵，旋转矩阵的实数特征值对应的特征向量即是axis-angle表达式的旋转轴，旋转矩阵的迹与旋转角度相关。 1.3 四元数 球面线性插值（Spherical linear interpolation，slerp) ![[1-SLAM 中的基础数学知识.png]] $$ Slerp(p,q,t) = \\frac{\\sin[(1-t)\\theta] + \\sin(t \\theta q)}{\\sin(\\theta)} $$ 1.4 旋转表示之间的相互转换 四元数转旋转向量 $$ \\begin{cases}{l} \\theta = 2\\arccos s \\\\ [n_x,n_y,n_z]^T = \\frac{v^T}{\\sin{\\frac{\\theta}{2}}} \\end{cases} $$\n旋转$\\theta\\boldsymbol{n}$向量转四元数 $$ \\boldsymbol{q} = [\\cos \\frac{\\theta}{2},\\boldsymbol{n} \\sin \\frac{\\theta}{2}] \\tag{2} $$\n旋转矩阵转旋转向量 $$ \\begin{cases} \\theta = \\arccos(\\frac{tr(\\boldsymbol{R})-1}{2}) \\\\[1ex] n = Rn, \\quad \\text{轴n是R特征值为1的单位特征向量} \\end{cases} \\tag{3} $$\n旋转向量$\\boldsymbol\\omega$转旋转矩阵（罗德里格斯公式） $$ \\boldsymbol{R} = \\cos\\theta \\boldsymbol{I} + (1- \\cos\\theta ) \\boldsymbol {n} \\boldsymbol {n}^T + \\sin\\theta \\boldsymbol {n}^{\\wedge} = exp{(\\boldsymbol{\\omega^{\\wedge}})} \\tag{4} $$ 旋转向量转旋转矩阵本质就是对应李代数的指数映射，李代数的指数映射将旋转向量映射为反对称矩阵\n旋转矩阵转四元数 $$ \\begin{cases} \\boldsymbol\\omega = \\frac{\\sqrt{1 + \\text{trace}(\\boldsymbol{R})}}{2} \\\\[1ex] \\boldsymbol{x} = \\frac{R_{32} - R_{23}}{4w} \\\\[1ex] \\boldsymbol{y} = \\frac{R_{13} - R_{31}}{4w} \\\\[1ex] \\boldsymbol{z} = \\frac{R_{21} - R_{12}}{4w} \\end{cases} \\tag{5} $$ $$ q = sqrt((R_{11} + R_{22} + R_{33} + 1) / 4) * [1, R_{23} - R_{32}, R_{31} - R_{13}, R_{12} - R_{21}] \\tag{6} $$\n四元数转旋转矩阵 $$ \\boldsymbol{R} = \\boldsymbol{v} \\boldsymbol{v}^T + s^2 + \\boldsymbol{I} + 2s \\boldsymbol{v}^{\\wedge} + (\\boldsymbol{v^{\\vee}})^2 \\tag{7} $$\n二维旋转角转旋转矩阵 $$ \\theta = \\begin{bmatrix} \\cos(x) \u0026amp; -sin(x) \\\\ sin(x) \u0026amp; cos(x) \\end{bmatrix} \\tag{8} $$\n欧拉角(roll,pitch,yaw)转旋转矩阵 $$ (roll,pitch,yaw) = (\\alpha,\\beta,\\phi) = \\begin{cases} R_{roll} \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; cos(\\alpha) \u0026amp; -sin(\\alpha) \\\\ 0 \u0026amp; sin(\\alpha) \u0026amp; cos(\\alpha) \\\\ \\end{bmatrix} \\\\[2ex] R_{pitch} \u0026amp;=\u0026amp; \\begin{bmatrix} cos(\\beta) \u0026amp; 0 \u0026amp; sin(\\beta) \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -sin(\\beta) \u0026amp; 0 \u0026amp; cos(\\beta) \\\\ \\end{bmatrix} \\\\[2ex] R_{yaw} \u0026amp;=\u0026amp; \\begin{bmatrix} cos(\\phi) \u0026amp; -sin(\\phi) \u0026amp; 0 \\\\ sin(\\phi) \u0026amp; cos(\\phi) \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\\\[2ex] R_{(\\alpha,\\beta,\\phi)} \u0026amp;=\u0026amp; R_{\\phi}*R_{\\beta}*R_{\\alpha}, \\text{一般采ZYX的顺序进行旋转叠加} \\end{cases} \\tag{9} $$\n计算向量与坐标轴之间的 rpy角 $$ \\begin{cases} roll \u0026amp;=\u0026amp; \\tan(z/y) \\\\ pich \u0026amp;=\u0026amp; \\tan(x/z) \\\\ yaw \u0026amp;=\u0026amp; \\tan(y/x) \\\\ \\end{cases} $$\n四元数转欧拉角（RPY） ![[2-SLAM 中的基础数学知识.png]]\n1.5 区别 四元数表示的旋转，可以更方便的进行插值运算 纯虚四元数的指数映射结果为单位四元数，而单位四元数可以表示空间中的旋转，所以四元数的旋转可以由纯虚四元数的指数映射表示 $$ \\boldsymbol{q} = exp(\\boldsymbol{\\tilde{w}}), \\quad \\boldsymbol{\\tilde{w}}\\text{表示纯虚四元数} $$ 四元数表示旋转时，旋转的角度只有李代数和旋转向量表示的一半，因为使用四元数进行旋转变换时需要进行两次乘法计算 $$\\boldsymbol{p^{\u0026rsquo;}} = \\boldsymbol{q} \\boldsymbol{p} \\boldsymbol{p^{-1}}$$ 其中$\\boldsymbol{p^{\u0026rsquo;}} 和 $\\boldsymbol{p}$ 分别为纯虚四元数表示的3d点坐标。\n李代数更适合表示连续的空间变化，其具有较好的微分性质，在导航和控制问题中更容易处理 一般传感器的测量结果都是角度（例如：IMU），角度可以很方便的转换为四元素，因此其计算非常高效，因此在 IMU 等高频计算场景中一般旋转四元素。但是在视觉 SLAM 中一般用旋转矩阵表示旋转，旋转矩阵可以很方便的通过指数映射转为李代数，并且视觉 SLAM 中需要直接对旋转进行优化，而李代数求导十分方便，所以更适合用李代数。（总结：角度的增量和插值计算用四元数，涉及旋转的导数运算用李代数） 2 常用数学公式 2.1 利群与李代数转换 $$ \\begin{aligned} exp(\\phi^{\\wedge}) \u0026amp;=R \\\\[1ex] \\phi \u0026amp;= log(R)^{\\vee} \\\\[1ex] \\phi^{\\wedge} \u0026amp;= log(R) \\end{aligned} $$\n2.2 叉积交换 $$ \\begin{aligned} a \\times b = - b \\times a \\\\ \\partial\\theta^{\\wedge} \\omega = \\omega^{\\wedge} \\partial\\theta \\end{aligned} $$\n2.3 SO(3) 伴随公式 $$ \\phi^{\\wedge}R = R(R^T\\phi)^{\\wedge} $$\n2.4 指数函数常用性质 $$ \\begin{cases} e^{x} = 1 + x + \\cdots + \\dfrac{x^n}{n!} \\\\[8pt] e^{-ax} = e^{-a} + e^{x} \\\\[8pt] e^{a+b} = e^{a}e^{b} \\end{cases} \\quad\\Rightarrow\\quad \\begin{cases} \\exp(x) = 1 + x \\\\[8pt] \\exp(\\theta + \\Delta\\theta) = \\exp(\\theta)\\exp(\\Delta\\theta) \\end{cases} $$### BCH 近似 BCH 公式关联了李群乘法与李代数加法之间的关系，李群（SO(3)）上乘小量等于李代数（so(3)）上加小量（带雅可比矩阵） $$ \\begin{aligned} exp(\\phi^{\\wedge})exp(\\Delta\\phi^{\\wedge}) \u0026amp; \\approx exp((\\phi+J_r^{-1}\\Delta\\phi)^{\\wedge}) \\\\ exp(\\phi+\\Delta\\phi) \u0026amp; \\approx exp(\\phi^{\\wedge})exp(J_r\\Delta\\phi^{\\wedge}) \\approx exp(J_l\\Delta\\phi^\\wedge)exp(\\phi^{\\wedge}) \\\\ Log(R exp(\\Delta \\phi)) \u0026amp; \\approx Log(R)+ J_r^{-1}(Log(R))\\Delta\\phi^{\\wedge} \\\\ log(\\prod_{k=1}^{j-1}exp(\\Delta\\phi ))^{\\vee} \u0026amp; \\approx \\sum_{k=i}^{j-1}\\Delta\\phi, \\quad \\text{由于 $\\Delta\\phi$ 为小量,所以假定了$J_r=I$} \\end{aligned} $$\nSO(3)上的BCH近似公式 BCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（李代数加法 ⇔ 李群乘法），其线性近似公式广泛应用于各种函数的线性化。 在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成： $$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$ 反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法： $$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge) $$ 其中SO(3)的左雅克比矩阵为 $$ \\begin{aligned} {J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\\\ {J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge} \\end{aligned} $$ 而SO(3)的右雅克比矩阵为 $$ {J}_r({\\phi}) = {J}_l(-{\\phi}) $$\n2.5 旋转求导 $$ \\begin{cases} \\dot{R} = Rw^{\\wedge}, \\quad \\text{该式也称为泊松方程，w为瞬时角速度} \\\\[1ex] \\dot{exp(\\delta\\theta^{\\wedge})} = exp(\\delta\\theta^{\\wedge})exp(\\delta\\dot{\\theta}^{\\wedge}) \\end{cases} $$\n3 几何变换 3.1 平面系数与平面法向量 平面方程 $$ ax+by+cz+d = 0 $$ 平面与各轴的交点： $$ \\begin{cases} P_x : (-\\frac{d}{a},0,0) \\\\ P_y : (0,-\\frac{d}{b},0) \\\\ P_z : (0,0,-\\frac{d}{c}) \\end{cases} $$ 点P(x,y,z)到平面$\\vec{n}$的距离 $$ d_p = \\frac{|\\vec{PP_x} \\vec{n}|}{|\\vec{n}|} $$\n6 KF、EKF、ESKF KF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数 Site Unreachable\nKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵 KF 假设运动方程为: $$ x_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。 $$ x_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T) $$ EKF 假设运动方程为: $$ x_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开： $$ f(x) = f(x_k) + J(x-x_k) $$ 所以下一时刻的$x_{k+1}$ 的分布为 $$ x_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T) $$ 其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。 ESKF ESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\n高斯分布的线性变换 若$x\\sim(\\mu,\\sigma^2)$，则$Ax+b \\sim (A\\mu+b,A\\sigma^2A^T)$ 高斯分布相乘 若$x\\sim(\\mu_0,\\sigma_0^2)$，$y\\sim(\\mu_1,\\sigma_1^2)$，则$x*y \\sim (A\\mu+b,A\\sigma^2A^T)$ ![[1-SLAM 基础.png]]\n4 为什么最小乘的解为最小特征值对应的特征向量 求一个最小二乘问题 $$ min||Ax = b||_2^2, \\quad x \\neq 0 \\quad and \\quad |x| = 1 $$ 首先我们要理解的是求 $Ax=b$ 的解就是求向量b在A矩阵的列空间（以列向量为基地张成的空间）中的像。假设$A=I$那么A的列空间就是欧式空间。如果$A \\neq I$ ,例如： $$ A = \\begin{bmatrix} 2 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$ 那么b在A的列空间中的像的x轴就会被压缩为1/2。这也就是我们常说的特征值表示的是列空间在各个列向量方向上的缩放比例。 接下来我们再看$|x|=1$,很明显在欧式空间中表示为$r=1$的球面构成的集合。但是由于b在A的列空间中的像的各轴坐标会被缩放，所以$|x|=1$在A的列空间中形成的是一个椭球。而求解 $min||Ax = b||_2^2$ 的问题即为在椭球面上找一点，使其到原心的距离最短。根据椭圆的知识我们很容易知道，椭圆上离原心最近的点为短轴与椭圆的交点。短轴则对应的是最小特征向量对应的坐标轴。也即最小二乘的解为最小特征值对应的特征向量。 反之 $max||Ax = b||_2^2$ 的解为最大特征值对应的特征向量\n5 为什么信息矩阵是协方差的逆 协方差表示了不同特征之间的相关性。而根据逆矩阵的伴随矩阵求法可知，的逆矩阵的第 i，j 个元$A_{i,j}$为去掉原矩阵的第i行和第j列之后的剩余元素的行列式与A矩阵行列式的比值。 $$ A^{-1} =\\frac{A^}{|A|},\\quad A^{i,j} 为去掉A{i,j}所在的行和列之后剩余元素的行列式 $$\nAppendix geometry_msgs::Quaternion EulerAngletoQuaternion(double yaw, double pitch, double roll) // yaw (Z), pitch (Y), roll (X) { // Abbreviations for the various angular functions double cy = cos(yaw * 0.5); double sy = sin(yaw * 0.5); double cp = cos(pitch * 0.5); double sp = sin(pitch * 0.5); double cr = cos(roll * 0.5); double sr = sin(roll * 0.5); geometry_msgs::Quaternion q; q.w = cy * cp * cr + sy * sp * sr; q.x = cy * cp * sr - sy * sp * cr; q.y = sy * cp * sr + cy * sp * cr; q.z = sy * cp * cr - cy * sp * sr; return q; } void QuaterniontoEulerAngle(const geometry_msgs::Quaternion \u0026amp;q, double \u0026amp;roll, double \u0026amp;pitch, double \u0026amp;yaw) { // roll (x-axis rotation) double sinr_cosp = +2.0 * (q.w * q.x + q.y * q.z); double cosr_cosp = +1.0 - 2.0 * (q.x * q.x + q.y * q.y); roll = atan2(sinr_cosp, cosr_cosp); // pitch (y-axis rotation) double sinp = +2.0 * (q.w * q.y - q.z * q.x); if (fabs(sinp) \u0026gt;= 1) pitch = copysign(M_PI / 2, sinp); // use 90 degrees if out of range else pitch = asin(sinp); // yaw (z-axis rotation) double siny_cosp = +2.0 * (q.w * q.z + q.x * q.y); double cosy_cosp = +1.0 - 2.0 * (q.y * q.y + q.z * q.z); yaw = atan2(siny_cosp, cosy_cosp); } double angle_normal(double original_ang) { if (original_ang \u0026gt; 3.1415926) original_ang -= piX2; else if (original_ang \u0026lt; -3.1415926) original_ang += piX2; return original_ang; } double angles_weight_mean(double angleA, double weightA, double angleB, double weightB) { //弧度 // double angleA_cal; // double angleB_cal; double mean{}, diff{}; if (angleA * angleB \u0026lt; 0) { if (angleA \u0026lt; 0) { diff = pi + angleA + pi - angleB; if (diff \u0026lt; pi) mean = angleB * weightB + (angleB + diff) * weightA; else mean = angleA * weightA + angleB * weightB; } if (angleB \u0026lt; 0) { diff = pi + angleB + pi - angleA; if (diff \u0026lt; pi) mean = angleA * weightA + (angleA + diff) * weightB; else mean = angleA * weightA + angleB * weightB; } } else { mean = angleA * weightA + angleB * weightB; } return angle_normal(mean); } 平面对齐：\n// 1. 计算两平面的旋转 // 法线叉乘计算两平面的旋转轴 Eigen::Vector3d rot_axis2 = slave_gplane.normal.cross(master_gplane.normal); rot_axis2.normalize(); // 法线点乘计算面的旋转角 double alpha2 = std::acos(slave_gplane.normal.dot(master_gplane.normal)); Eigen::Matrix3d R_ms; // 平面对齐的旋转向量 R_ms = Eigen::AngleAxisd(alpha2, rot_axis2); // 2. 计算两平面的平移 // 平面于z轴的交点 intercept-截距 normal-法线 Eigen::Vector3d slave_intcpt_local( 0, 0, -slave_gplane.intercept / slave_gplane.normal(2)); // 交点旋转到对准点云 Eigen::Vector3d slave_intcpt_master = R_ms * slave_intcpt_local; // 计算平面对齐的平移变量 ？？ 为什么只移动z轴坐标，这样可以将平面重合，平面上的点也能对应吗？ Eigen::Vector3d t_ms(0, 0, t_mp(2) - slave_intcpt_master(2)); ","permalink":"https://zhouwuxiong.github.io/posts/slam-%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","summary":"\u003ch2 id=\"1-旋转的表示\"\u003e1 旋转的表示\u003c/h2\u003e\n\u003ch3 id=\"11-旋转向量\"\u003e1.1 旋转向量\u003c/h3\u003e\n\u003ch3 id=\"12-旋转矩阵\"\u003e1.2 旋转矩阵\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e旋转矩阵有且只有一个实数特征值1；\u003c/li\u003e\n\u003cli\u003e不考虑单位矩阵，旋转矩阵的实数特征值对应的特征向量即是axis-angle表达式的旋转轴，旋转矩阵的迹与旋转角度相关。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"13-四元数\"\u003e1.3 四元数\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://cnblogs.com/21207-iHome/p/6952004.html\"\u003e球面线性插值（Spherical linear interpolation，slerp)\u003c/a\u003e\n![[1-SLAM 中的基础数学知识.png]]\n$$\nSlerp(p,q,t) = \\frac{\\sin[(1-t)\\theta] + \\sin(t \\theta q)}{\\sin(\\theta)}\n$$\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"14-旋转表示之间的相互转换\"\u003e1.4 旋转表示之间的相互转换\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e四元数转旋转向量\n$$\n\\begin{cases}{l}\n\\theta = 2\\arccos s \\\\\n[n_x,n_y,n_z]^T = \\frac{v^T}{\\sin{\\frac{\\theta}{2}}}\n\\end{cases}\n$$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e旋转$\\theta\\boldsymbol{n}$向量转四元数\n$$\n\\boldsymbol{q} = [\\cos \\frac{\\theta}{2},\\boldsymbol{n} \\sin \\frac{\\theta}{2}] \\tag{2}\n$$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e旋转矩阵转旋转向量\n$$\n\\begin{cases}\n\\theta = \\arccos(\\frac{tr(\\boldsymbol{R})-1}{2}) \\\\[1ex]\nn = Rn, \\quad \\text{轴n是R特征值为1的单位特征向量}\n\\end{cases}\n\\tag{3}\n$$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e旋转向量$\\boldsymbol\\omega$转旋转矩阵（\u003cem\u003e罗德里格斯公式\u003c/em\u003e）\n$$\n\\boldsymbol{R} = \\cos\\theta \\boldsymbol{I} + (1- \\cos\\theta ) \\boldsymbol {n} \\boldsymbol {n}^T + \\sin\\theta  \\boldsymbol {n}^{\\wedge} = exp{(\\boldsymbol{\\omega^{\\wedge}})}\n\\tag{4}\n$$\n\u003cem\u003e旋转向量转旋转矩阵本质就是对应李代数的指数映射，李代数的指数映射将旋转向量映射为反对称矩阵\u003c/em\u003e\u003c/p\u003e","title":"SLAM 中的基础数学知识"},{"content":"1 BoW ORB_SLAM 使用 BoW 进行相似图像检索，在重定位、回环检测、参考关键帧跟踪过程中都有用到。BoW 是一种 K 叉树形式的分类树，在构造 K 叉树时，根据特征描述的相似性作为距离度量进行聚类，树的叶子节点被计为单词，每个单词使用特征点的聚类中心表示。在进行特征匹配时，根据特征点是否落在同一个叶子节点判断是否对应同一个单词，同时可以得到一个相似度得分。一般在进行图像特征匹配时会根据公共单词数量和最小的相似度得分判断图像之间的相似性。 1.1 TF-IDF TF（Term Frequency），指在单帧中某个单词的频次，频次高，权重大 IDF（Inverse Document Frequency），某个单词在词典中出现的频次，频次越低，则辨识度越高，相应权重 IDF 越大 最终 BoW 的权重是 TF*IDF ，每个单词都有自己的权重。\n1.2 正向索引 再计算BoW时，每帧图像会记录一个正向索引表，记录在kd树某一层，命中的节点集合，以及节点中的特征点，用于加速两帧图像之间的特征点匹配。\n1.3 逆向索引 orb-slam 中维护了一个关键帧数据库，其中有一个单词的逆向索引表，其记录了包含这个单词的关键帧和权重，用于快速查找匹配关键帧。\n1.4 相似性对量 L1 ，各维度的差值的绝对值求和 余弦相似度 ，向量夹角 1.5 levelsup ORB_SLAM 在对图像生成词向量时，会根据 levelsup 记录图像中的单词落在了某层的哪些分支，这样在进行单词匹配时，只需要查找对应分支而不是从根节点开始查找，提高查找效率。 Reference: 基于词袋模型的图像匹配 - Line\u0026rsquo;s Blog\nAppendix:\n/* * @brief 通过词袋，对关键帧的特征点进行跟踪，该函数用于闭环检测时两个关键帧间的特征点匹配 * @details 通过bow对pKF和F中的特征点进行快速匹配（不属于同一node的特征点直接跳过匹配） * 对属于同一node的特征点通过描述子距离进行匹配 * 通过距离阈值、比例阈值和角度投票进行剔除误匹配 * @param pKF1 KeyFrame1 * @param pKF2 KeyFrame2 * @param vpMatches12 pKF2中与pKF1匹配的MapPoint，vpMatches12[i]表示匹配的地图点，null表示没有匹配，i表示匹配的pKF1 特征点索引 * @return 成功匹配的数量 */ int ORBmatcher::SearchByBoW(KeyFrame *pKF1, KeyFrame *pKF2, vector\u0026lt;MapPoint *\u0026gt; \u0026amp;vpMatches12) { // Step 1 分别取出两个关键帧的特征点、BoW 向量、地图点、描述子 const vector\u0026lt;cv::KeyPoint\u0026gt; \u0026amp;vKeysUn1 = pKF1-\u0026gt;mvKeysUn; const DBoW2::FeatureVector \u0026amp;vFeatVec1 = pKF1-\u0026gt;mFeatVec; const vector\u0026lt;MapPoint*\u0026gt; vpMapPoints1 = pKF1-\u0026gt;GetMapPointMatches(); const cv::Mat \u0026amp;Descriptors1 = pKF1-\u0026gt;mDescriptors; const vector\u0026lt;cv::KeyPoint\u0026gt; \u0026amp;vKeysUn2 = pKF2-\u0026gt;mvKeysUn; const DBoW2::FeatureVector \u0026amp;vFeatVec2 = pKF2-\u0026gt;mFeatVec; const vector\u0026lt;MapPoint*\u0026gt; vpMapPoints2 = pKF2-\u0026gt;GetMapPointMatches(); const cv::Mat \u0026amp;Descriptors2 = pKF2-\u0026gt;mDescriptors; // 保存匹配结果 vpMatches12 = vector\u0026lt;MapPoint*\u0026gt;(vpMapPoints1.size(),static_cast\u0026lt;MapPoint*\u0026gt;(NULL)); vector\u0026lt;bool\u0026gt; vbMatched2(vpMapPoints2.size(),false); // Step 2 构建旋转直方图，HISTO_LENGTH = 30 vector\u0026lt;int\u0026gt; rotHist[HISTO_LENGTH]; for(int i=0;i\u0026lt;HISTO_LENGTH;i++) rotHist[i].reserve(500); //! 原作者代码是 const float factor = 1.0f/HISTO_LENGTH; 是错误的，更改为下面代码 const float factor = HISTO_LENGTH/360.0f; int nmatches = 0; DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin(); DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin(); DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end(); DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end(); while(f1it != f1end \u0026amp;\u0026amp; f2it != f2end) { // Step 3 开始遍历，分别取出属于同一node的特征点(只有属于同一node，才有可能是匹配点) if(f1it-\u0026gt;first == f2it-\u0026gt;first) { // 遍历KF中属于该node的特征点 for(size_t i1=0, iend1=f1it-\u0026gt;second.size(); i1\u0026lt;iend1; i1++) { const size_t idx1 = f1it-\u0026gt;second[i1]; MapPoint* pMP1 = vpMapPoints1[idx1]; if(!pMP1) continue; if(pMP1-\u0026gt;isBad()) continue; const cv::Mat \u0026amp;d1 = Descriptors1.row(idx1); int bestDist1=256; int bestIdx2 =-1 ; int bestDist2=256; // Step 4 遍历KF2中属于该node的特征点，找到了最优及次优匹配点 for(size_t i2=0, iend2=f2it-\u0026gt;second.size(); i2\u0026lt;iend2; i2++) { const size_t idx2 = f2it-\u0026gt;second[i2]; MapPoint* pMP2 = vpMapPoints2[idx2]; // 如果已经有匹配的点，或者遍历到的特征点对应的地图点无效 if(vbMatched2[idx2] || !pMP2) continue; if(pMP2-\u0026gt;isBad()) continue; const cv::Mat \u0026amp;d2 = Descriptors2.row(idx2); int dist = DescriptorDistance(d1,d2); if(dist\u0026lt;bestDist1) { bestDist2=bestDist1; bestDist1=dist; bestIdx2=idx2; } else if(dist\u0026lt;bestDist2) { bestDist2=dist; } } // Step 5 对匹配结果进行检查，满足阈值、最优/次优比例，记录旋转直方图信息 if(bestDist1\u0026lt;TH_LOW) { if(static_cast\u0026lt;float\u0026gt;(bestDist1)\u0026lt;mfNNratio*static_cast\u0026lt;float\u0026gt;(bestDist2)) { vpMatches12[idx1]=vpMapPoints2[bestIdx2]; vbMatched2[bestIdx2]=true; if(mbCheckOrientation) { float rot = vKeysUn1[idx1].angle-vKeysUn2[bestIdx2].angle; if(rot\u0026lt;0.0) rot+=360.0f; int bin = round(rot*factor); if(bin==HISTO_LENGTH) bin=0; assert(bin\u0026gt;=0 \u0026amp;\u0026amp; bin\u0026lt;HISTO_LENGTH); rotHist[bin].push_back(idx1); } nmatches++; } } } f1it++; f2it++; } else if(f1it-\u0026gt;first \u0026lt; f2it-\u0026gt;first) { f1it = vFeatVec1.lower_bound(f2it-\u0026gt;first); } else { f2it = vFeatVec2.lower_bound(f1it-\u0026gt;first); } } // Step 6 检查旋转直方图分布，剔除差异较大的匹配 if(mbCheckOrientation) { int ind1=-1; int ind2=-1; int ind3=-1; ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3); for(int i=0; i\u0026lt;HISTO_LENGTH; i++) { if(i==ind1 || i==ind2 || i==ind3) continue; for(size_t j=0, jend=rotHist[i].size(); j\u0026lt;jend; j++) { vpMatches12[rotHist[i][j]]=static_cast\u0026lt;MapPoint*\u0026gt;(NULL); nmatches--; } } } return nmatches; } ","permalink":"https://zhouwuxiong.github.io/posts/image_match/","summary":"\u003ch2 id=\"1-bow\"\u003e1 BoW\u003c/h2\u003e\n\u003cp\u003eORB_SLAM 使用 BoW 进行相似图像检索，在重定位、回环检测、参考关键帧跟踪过程中都有用到。BoW 是一种 K 叉树形式的分类树，在构造 K 叉树时，根据特征描述的相似性作为距离度量进行聚类，树的叶子节点被计为单词，每个单词使用特征点的聚类中心表示。在进行特征匹配时，根据特征点是否落在同一个叶子节点判断是否对应同一个单词，同时可以得到一个相似度得分。一般在进行图像特征匹配时会根据公共单词数量和最小的相似度得分判断图像之间的相似性。\n\u003cimg alt=\"1-Image_Match.png\" loading=\"lazy\" src=\"1-Image_Match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"11-tf-idf\"\u003e1.1 TF-IDF\u003c/h3\u003e\n\u003cp\u003eTF（Term Frequency），指在单帧中某个单词的频次，频次高，权重大\nIDF（Inverse Document Frequency），某个单词在词典中出现的频次，频次越低，则辨识度越高，相应权重 IDF 越大\n最终 BoW 的权重是 \u003ccode\u003eTF*IDF\u003c/code\u003e ，每个单词都有自己的权重。\u003c/p\u003e\n\u003ch3 id=\"12-正向索引\"\u003e1.2 正向索引\u003c/h3\u003e\n\u003cp\u003e再计算BoW时，每帧图像会记录一个正向索引表，记录在kd树某一层，命中的节点集合，以及节点中的特征点，用于加速两帧图像之间的特征点匹配。\u003c/p\u003e\n\u003ch3 id=\"13-逆向索引\"\u003e1.3 逆向索引\u003c/h3\u003e\n\u003cp\u003eorb-slam 中维护了一个关键帧数据库，其中有一个单词的逆向索引表，其记录了包含这个单词的关键帧和权重，用于快速查找匹配关键帧。\u003c/p\u003e\n\u003ch3 id=\"14-相似性对量\"\u003e1.4 相似性对量\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eL1  ，各维度的差值的绝对值求和\u003c/li\u003e\n\u003cli\u003e余弦相似度 ，向量夹角\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"15-levelsup\"\u003e1.5 levelsup\u003c/h3\u003e\n\u003cp\u003eORB_SLAM 在对图像生成词向量时，会根据 levelsup 记录图像中的单词落在了某层的哪些分支，这样在进行单词匹配时，只需要查找对应分支而不是从根节点开始查找，提高查找效率。\n\u003cimg alt=\"2-Image_Match.png\" loading=\"lazy\" src=\"2-Image_Match.png\"\u003e\u003c/p\u003e\n\u003cp\u003eReference:\n\u003ca href=\"https://xhy3054.github.io/2019/04/19/2019-04-19-bow/\"\u003e基于词袋模型的图像匹配 - Line\u0026rsquo;s Blog\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAppendix:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * @brief 通过词袋，对关键帧的特征点进行跟踪，该函数用于闭环检测时两个关键帧间的特征点匹配\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * @details 通过bow对pKF和F中的特征点进行快速匹配（不属于同一node的特征点直接跳过匹配） \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * 对属于同一node的特征点通过描述子距离进行匹配 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * 通过距离阈值、比例阈值和角度投票进行剔除误匹配\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * @param  pKF1               KeyFrame1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * @param  pKF2               KeyFrame2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * @param  vpMatches12        pKF2中与pKF1匹配的MapPoint，vpMatches12[i]表示匹配的地图点，null表示没有匹配，i表示匹配的pKF1 特征点索引\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e * @return                    成功匹配的数量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eORBmatcher\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eSearchByBoW\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eKeyFrame\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epKF1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eKeyFrame\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epKF2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003evpMatches12\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// Step 1 分别取出两个关键帧的特征点、BoW 向量、地图点、描述子\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecv\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eKeyPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003evKeysUn1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emvKeysUn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eDBoW2\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFeatureVector\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003evFeatVec1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emFeatVec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evpMapPoints1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetMapPointMatches\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ecv\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eDescriptors1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emDescriptors\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecv\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eKeyPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003evKeysUn2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emvKeysUn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eDBoW2\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFeatureVector\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003evFeatVec2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emFeatVec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evpMapPoints2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetMapPointMatches\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ecv\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eDescriptors2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epKF2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emDescriptors\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 保存匹配结果\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evpMatches12\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evpMapPoints1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evbMatched2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evpMapPoints2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// Step 2 构建旋转直方图，HISTO_LENGTH = 30\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erotHist\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003erotHist\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003ereserve\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e500\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e//! 原作者代码是 const float factor = 1.0f/HISTO_LENGTH; 是错误的，更改为下面代码   \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003efactor\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"mf\"\u003e360.0f\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003enmatches\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eDBoW2\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFeatureVector\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003econst_iterator\u003c/span\u003e \u003cspan class=\"n\"\u003ef1it\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evFeatVec1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eDBoW2\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFeatureVector\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003econst_iterator\u003c/span\u003e \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evFeatVec2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eDBoW2\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFeatureVector\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003econst_iterator\u003c/span\u003e \u003cspan class=\"n\"\u003ef1end\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evFeatVec1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eDBoW2\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFeatureVector\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003econst_iterator\u003c/span\u003e \u003cspan class=\"n\"\u003ef2end\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evFeatVec2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef1it\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003ef1end\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003ef2end\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// Step 3 开始遍历，分别取出属于同一node的特征点(只有属于同一node，才有可能是匹配点)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef1it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// 遍历KF中属于该node的特征点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003ei1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eiend1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ef1it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esecond\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"n\"\u003ei1\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eiend1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei1\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003eidx1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef1it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esecond\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei1\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epMP1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evpMapPoints1\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx1\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003epMP1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMP1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eisBad\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ecv\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ed1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eDescriptors1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebestDist1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e256\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebestIdx2\u003c/span\u003e \u003cspan class=\"o\"\u003e=-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebestDist2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e256\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// Step 4 遍历KF2中属于该node的特征点，找到了最优及次优匹配点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003ei2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eiend2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ef2it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esecond\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"n\"\u003ei2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eiend2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei2\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003eidx2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esecond\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei2\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epMP2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evpMapPoints2\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx2\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"c1\"\u003e// 如果已经有匹配的点，或者遍历到的特征点对应的地图点无效\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evbMatched2\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx2\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003epMP2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMP2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eisBad\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ecv\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ed2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eDescriptors2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003edist\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eDescriptorDistance\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ed1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ed2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edist\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ebestDist1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ebestDist2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ebestDist1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ebestDist1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003edist\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ebestIdx2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eidx2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"nf\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edist\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ebestDist2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ebestDist2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003edist\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// Step 5 对匹配结果进行检查，满足阈值、最优/次优比例，记录旋转直方图信息\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebestDist1\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTH_LOW\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebestDist1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003emfNNratio\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebestDist2\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003evpMatches12\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003evpMapPoints2\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ebestIdx2\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003evbMatched2\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ebestIdx2\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003embCheckOrientation\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003erot\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evKeysUn1\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx1\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eangle\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003evKeysUn2\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ebestIdx2\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eangle\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erot\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003erot\u003c/span\u003e\u003cspan class=\"o\"\u003e+=\u003c/span\u003e\u003cspan class=\"mf\"\u003e360.0f\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebin\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eround\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erot\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efactor\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"n\"\u003eassert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"n\"\u003erotHist\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003epush_back\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003enmatches\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ef1it\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"nf\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef1it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ef1it\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evFeatVec1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elower_bound\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef2it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ef2it\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003evFeatVec2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elower_bound\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef1it\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// Step 6 检查旋转直方图分布，剔除差异较大的匹配\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003embCheckOrientation\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eind1\u003c/span\u003e\u003cspan class=\"o\"\u003e=-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eind2\u003c/span\u003e\u003cspan class=\"o\"\u003e=-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eind3\u003c/span\u003e\u003cspan class=\"o\"\u003e=-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eComputeThreeMaxima\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erotHist\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eind1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eind2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eind3\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHISTO_LENGTH\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"n\"\u003eind1\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"n\"\u003eind2\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"n\"\u003eind3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ejend\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003erotHist\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ejend\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003evpMatches12\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003erotHist\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e][\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMapPoint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003enmatches\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003enmatches\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"图像匹配"},{"content":"一个好的特征描述符应该至少保留以下特征：\n旋转不变性 尺度不变性 光度不敏感 1 ORB 特征提取 124456789 ORB - (Oriented Fast and Rotated BRIEF)算法是基于FAST特征检测与BRIEF特征描述子匹配实现，相比BRIEF算法中依靠随机方式获取而值点对，ORB通过FAST方法，FAST方式寻找候选特征点方式是假设灰度图像像素点A周围的像素存在连续大于或者小于A的灰度值。\n1.1 Fast 角点 FAST角点定义为：若某像素点与周围邻域足够多的像素点处于不同区域，则该像素可能为角点。考虑灰度图像，即若某像素点的灰度值比周围邻域足够多的像素点的灰度值大或小，则该点可能为角点。\n对于图像中一个像素点$p$，其灰度值为$I_p$ 以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素(如下图所示) 设定一个合适的阈值$t$，如果圆上有n个连续像素点的灰度值小于$I_p−t$或者大于$I_p+t$，那么这个点即可判断为角点(n的值可取12或9) 一种快速排除大部分非角点像素的方法就是检查周围1、5、9、13四个位置的像素，如果位置1和9与中心像素P点的灰度差小于给定阈值，则P点不可能是角点，直接排除；否则进一步判断位置5和13与中心像素的灰度差，如果四个像素中至少有3个像素与P点的灰度差超过阈值，则考察邻域圆上16个像素点与中心点的灰度差，如果有至少9个超过给定阈值则认为是角点。 Fast 检测出角点很多都是相邻的，Fast 对其做了非极大值一致处理，对于每个 Fast 交点使用其周围 16 个像素与中心点像素差值的绝对值之和作为得分，对于相邻的像素选择得分最大的点。\n1.2 brief 特征描述符 brief 特征描述的原理是在关键点周围随机选取 N 个点对，对比像素点的像素值大小，根据其像素值的大小得到(0，1)编码，这种二进制编码的表示，可以进行快速的特征匹配和相似度计算。\n1.3 旋转不变性 brief 本身不具有灰度不变性 ，为了保证旋转不变性，ORB 通过关键点邻域内的灰度质心作为特征点的主方向。计算特征描述符时先将主方向旋转为一致，再计算 brief 特征描述符，从而保证旋转不变性。但是旋转后的特征描述符虽然具有了旋转不变性，但是可区分度变弱了。如下图所示，为几种特征描述子的均值分布，横轴为均值与0.5之间的距离，纵轴为相应均值下特征点的统计数量。可以看出，BRIEF描述子所有比特位的均值接近于0.5，且方差很大；方差越大表明可区分性越好。不同特征点的描述子表现出较大的差异性，不易造成无匹配。但steered BRIEF进行了坐标旋转，损失了这个特性，导致可区分性减弱，相关性变强，不利于匹配。为了解决这个问题， ORB 使用了一种基于学习的方法来选择一定数量的随机点对，详情见 图像特征描述子之ORB | Senit_Co。\n1.4 特征均匀化 在根据特征点进行位姿求解时，我们希望特征点是比较分散的而不是集中在小块的区域。因为这样可以产生更强的和约束，使得位姿求解更精确。ORB 在进行特征提取时使用了两个 tips 来均匀化特征点。1. 根据图像金字塔的分辨率比例分配每层图像需要提取的特征点数量。2. 使四叉树分裂的方式均匀化特征点，具体方法是对提取所有特征点后对图像进行四叉树分块，如果块中的特征点数量大于1个则进行继续分裂或选取响应值(Fast 交点的得分)最大的特征点，是否分裂取决于是否达到了期望的特征点数量。 1.5 Reference: 图像特征之FAST角点检测 | Senit_Co 图像特征描述子之ORB | Senit_Co Site Unreachable\n2 SIFT Reference: SIFT 特征 - SLAM 之旅\n关于 SLAM - SLAM 之旅\n","permalink":"https://zhouwuxiong.github.io/posts/feature_match/","summary":"\u003cp\u003e一个好的特征描述符应该至少保留以下特征：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e旋转不变性\u003c/li\u003e\n\u003cli\u003e尺度不变性\u003c/li\u003e\n\u003cli\u003e光度不敏感\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"1-orb-特征提取-124456789\"\u003e1 ORB 特征提取 124456789\u003c/h2\u003e\n\u003cp\u003eORB - (Oriented Fast and Rotated BRIEF)算法是基于FAST特征检测与BRIEF特征描述子匹配实现，相比BRIEF算法中依靠随机方式获取而值点对，ORB通过FAST方法，FAST方式寻找候选特征点方式是假设灰度图像像素点A周围的像素存在连续大于或者小于A的灰度值。\u003c/p\u003e\n\u003ch3 id=\"11-fast-角点\"\u003e1.1 Fast 角点\u003c/h3\u003e\n\u003cp\u003e FAST角点定义为：若某像素点与周围邻域足够多的像素点处于不同区域，则该像素可能为角点。考虑灰度图像，即若某像素点的灰度值比周围邻域足够多的像素点的灰度值大或小，则该点可能为角点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于图像中一个像素点$p$，其灰度值为$I_p$\u003c/li\u003e\n\u003cli\u003e以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素(如下图所示)\u003c/li\u003e\n\u003cli\u003e设定一个合适的阈值$t$，如果圆上有n个连续像素点的灰度值小于$I_p−t$或者大于$I_p+t$，那么这个点即可判断为角点(n的值可取12或9)\n \u003cimg alt=\"1-feature_match.png\" loading=\"lazy\" src=\"1-feature_match.png\"\u003e\n一种快速排除大部分非角点像素的方法就是检查周围1、5、9、13四个位置的像素，如果位置1和9与中心像素P点的灰度差小于给定阈值，则P点不可能是角点，直接排除；否则进一步判断位置5和13与中心像素的灰度差，如果四个像素中至少有3个像素与P点的灰度差超过阈值，则考察邻域圆上16个像素点与中心点的灰度差，如果有至少9个超过给定阈值则认为是角点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFast 检测出角点很多都是相邻的，Fast 对其做了非极大值一致处理，对于每个 Fast 交点使用其周围 16 个像素与中心点像素差值的绝对值之和作为得分，对于相邻的像素选择得分最大的点。\u003c/p\u003e\n\u003ch3 id=\"12-brief-特征描述符\"\u003e1.2 brief 特征描述符\u003c/h3\u003e\n\u003cp\u003ebrief 特征描述的原理是在关键点周围随机选取 N 个点对，对比像素点的像素值大小，根据其像素值的大小得到(0，1)编码，这种二进制编码的表示，可以进行快速的特征匹配和相似度计算。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"2-feature_match.png\" loading=\"lazy\" src=\"2-feature_match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"13-旋转不变性\"\u003e1.3 旋转不变性\u003c/h3\u003e\n\u003cp\u003ebrief  本身不具有灰度不变性 ，为了保证旋转不变性，ORB 通过关键点邻域内的\u003ca href=\"https://zhuanlan.zhihu.com/p/481373935\"\u003e灰度质心\u003c/a\u003e作为特征点的主方向。计算特征描述符时先将主方向旋转为一致，再计算 brief 特征描述符，从而保证旋转不变性。但是旋转后的特征描述符虽然具有了旋转不变性，但是可区分度变弱了。如下图所示，为几种特征描述子的均值分布，横轴为均值与0.5之间的距离，纵轴为相应均值下特征点的统计数量。可以看出，BRIEF描述子所有比特位的均值接近于0.5，且方差很大；方差越大表明可区分性越好。不同特征点的描述子表现出较大的差异性，不易造成无匹配。但steered BRIEF进行了坐标旋转，损失了这个特性，导致可区分性减弱，相关性变强，不利于匹配。为了解决这个问题， ORB 使用了一种基于学习的方法来选择一定数量的随机点对，详情见 \u003ca href=\"https://senitco.github.io/2017/07/09/image-feature-orb/\"\u003e图像特征描述子之ORB | Senit_Co\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"3-feature_match.png\" loading=\"lazy\" src=\"3-feature_match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"14-特征均匀化\"\u003e1.4 特征均匀化\u003c/h3\u003e\n\u003cp\u003e在根据特征点进行位姿求解时，我们希望特征点是比较分散的而不是集中在小块的区域。因为这样可以产生更强的和约束，使得位姿求解更精确。ORB 在进行特征提取时使用了两个 tips 来均匀化特征点。1. 根据图像金字塔的分辨率比例分配每层图像需要提取的特征点数量。2. 使四叉树分裂的方式均匀化特征点，具体方法是对提取所有特征点后对图像进行四叉树分块，如果块中的特征点数量大于1个则进行继续分裂或选取响应值(Fast 交点的得分)最大的特征点，是否分裂取决于是否达到了期望的特征点数量。\n\u003cimg alt=\"6-feature_match.png\" loading=\"lazy\" src=\"6-feature_match.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"15-reference\"\u003e1.5 Reference:\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://senitco.github.io/2017/06/30/image-feature-fast/\"\u003e图像特征之FAST角点检测 | Senit_Co\u003c/a\u003e\n\u003ca href=\"https://senitco.github.io/2017/07/09/image-feature-orb/\"\u003e图像特征描述子之ORB | Senit_Co\u003c/a\u003e\n\u003ca href=\"https://zhuanlan.zhihu.com/p/481373935\"\u003eSite Unreachable\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"2-sift\"\u003e2 SIFT\u003c/h2\u003e\n\u003cp\u003eReference:\n\u003ca href=\"https://lsxiang.github.io/Journey2SLAM/computer_vision/SIFT/\"\u003eSIFT 特征 - SLAM 之旅\u003c/a\u003e\u003c/p\u003e","title":"图像特征点"},{"content":"1 常见符号表示 2 SO(3)上的BCH近似公式 BCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（李代数加法 ⇔ 李群乘法），其线性近似公式广泛应用于各种函数的线性化。 在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成： $$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$ 反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法： $$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge) $$ 其中SO(3)的左雅克比矩阵为 $$ \\begin{aligned} {J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\{J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge} \\end{aligned} $$ 而SO(3)的右雅克比矩阵为 $$ {J}_r({\\phi}) = {J}_l(-{\\phi}) $$\n3 KF、EKF、ESKF KF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数 Site Unreachable\nKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵 KF 假设运动方程为: $$ x_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。 $$ x_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T) $$ EKF 假设运动方程为: $$ x_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开： $$ f(x) = f(x_k) + J(x-x_k) $$ 所以下一时刻的$x_{k+1}$ 的分布为 $$ x_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T) $$ 其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。 ESKF ESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\n高斯分布的线性变换 若$x\\sim(\\mu,\\sigma^2)$，则$Ax+b \\sim (A\\mu+b,A\\sigma^2A^T)$ 高斯分布相乘 若$x\\sim(\\mu_0,\\sigma_0^2)$，$y\\sim(\\mu_1,\\sigma_1^2)$，则$x*y \\sim (A\\mu+b,A\\sigma^2A^T)$ 4 常用数学公式 5 利群与李代数转换 $$ \\begin{aligned} exp(\\phi^{\\wedge}) \u0026amp;=R \\\\[1ex] \\phi \u0026amp;= log(R)^{\\vee} \\\\[1ex] \\phi^{\\wedge} \u0026amp;= log(R) \\end{aligned} $$\n5.1 叉积交换 $$ \\begin{aligned} a \\times b = - b \\times a \\\\ \\partial\\theta^{\\wedge} \\omega = \\omega^{\\wedge} \\partial\\theta \\end{aligned} $$\n5.2 SO(3) 伴随公式 $$ \\phi^{\\wedge}R = R(R^T\\phi)^{\\wedge} $$\n5.3 指数函数常用性质 124 $$ \\begin{cases} e^{x} = 1 + x + \\cdots + \\dfrac{x^n}{n!} \\[8pt] e^{-ax} = e^{-a} + e^{x} \\[8pt] e^{a+b} = e^{a}e^{b} \\end{cases} \\quad\\Rightarrow\\quad \\begin{cases} \\exp(x) = 1 + x \\[8pt] \\exp(\\theta + \\Delta\\theta) = \\exp(\\theta)\\exp(\\Delta\\theta) \\end{cases} $$### BCH 近似 BCH 公式关联了李群乘法与李代数加法之间的关系，李群（SO(3)）上乘小量等于李代数（so(3)）上加小量（带雅可比矩阵） $$ \\begin{aligned} exp(\\phi^{\\wedge})exp(\\Delta\\phi^{\\wedge}) \\approx exp((\\phi+J_r^{-1}\\Delta\\phi)^{\\wedge})\n\\\\[1ex]\nexp(\\phi+\\Delta\\phi) \\approx exp(\\phi^{\\wedge})exp(J_r\\Delta\\phi^{\\wedge}) \\approx exp(J_l\\Delta\\phi^\\wedge)exp(\\phi^{\\wedge})\n\\\\[1ex]\nLog(R exp(\\Delta \\phi)) \\approx Log(R)+ J_r^{-1}(Log(R))\\Delta\\phi^{\\wedge}\n\\\\[1ex]\nlog(\\prod_{k=1}^{j-1}exp(\\Delta\\phi ))^{\\vee} \\approx \\sum_{k=i}^{j-1}\\Delta\\phi, \\quad \\text{由于 $\\Delta\\phi$ 为小量,所以假定了$J_r=I$} \\end{aligned} $$\n旋转求导 $$ \\begin{cases} \\dot{R} = Rw^{\\wedge}, \\quad \\text{该式也称为泊松方程，w为瞬时角速度}\n\\\\[1ex]\n\\dot{exp(\\delta\\theta^{\\wedge})} = exp(\\delta\\theta^{\\wedge})exp(\\delta\\dot{\\theta}^{\\wedge}) \\end{cases} $$\n","permalink":"https://zhouwuxiong.github.io/posts/slam-%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"1-常见符号表示\"\u003e1 常见符号表示\u003c/h2\u003e\n\u003ch2 id=\"2-so3上的bch近似公式\"\u003e2  SO(3)上的BCH近似公式\u003c/h2\u003e\n\u003cp\u003eBCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（\u003cstrong\u003e李代数加法 ⇔ 李群乘法\u003c/strong\u003e），其线性近似公式广泛应用于各种函数的线性化。\n在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成：\n$$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$\n反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法：\n$$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge)\n$$\n其中SO(3)的左雅克比矩阵为\n$$\n\\begin{aligned}\n{J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\{J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge}\n\\end{aligned}\n$$\n而SO(3)的右雅克比矩阵为\n$$\n{J}_r({\\phi}) = {J}_l(-{\\phi})\n$$\u003c/p\u003e\n\u003ch2 id=\"3-kfekfeskf\"\u003e3 KF、EKF、ESKF\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eKF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数\u003c/strong\u003e\n\u003ca href=\"https://zhuanlan.zhihu.com/p/39912633\"\u003eSite Unreachable\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵\n\u003cstrong\u003eKF\u003c/strong\u003e\n假设运动方程为:\n$$\nx_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2)\n$$\n由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。\n$$\nx_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T)\n$$\n\u003cstrong\u003eEKF\u003c/strong\u003e\n假设运动方程为:\n$$\nx_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2)\n$$\n其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开：\n$$\nf(x) = f(x_k) + J(x-x_k)\n$$\n所以下一时刻的$x_{k+1}$ 的分布为\n$$\nx_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T)\n$$\n其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。\n\u003cstrong\u003eESKF\u003c/strong\u003e\nESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\u003c/p\u003e","title":"SLAM 基础"},{"content":"1 常见符号表示 2 SO(3)上的BCH近似公式 BCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（李代数加法 ⇔ 李群乘法），其线性近似公式广泛应用于各种函数的线性化。 在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成： $$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$ 反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法： $$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge) $$ 其中SO(3)的左雅克比矩阵为 $$ \\begin{aligned} {J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\{J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge} \\end{aligned} $$ 而SO(3)的右雅克比矩阵为 $$ {J}_r({\\phi}) = {J}_l(-{\\phi}) $$\n3 KF、EKF、ESKF KF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数 Site Unreachable\nKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵 KF 假设运动方程为: $$ x_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。 $$ x_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T) $$ EKF 假设运动方程为: $$ x_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开： $$ f(x) = f(x_k) + J(x-x_k) $$ 所以下一时刻的$x_{k+1}$ 的分布为 $$ x_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T) $$ 其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。 ESKF ESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\n高斯分布的线性变换 若$x\\sim(\\mu,\\sigma^2)$，则$Ax+b \\sim (A\\mu+b,A\\sigma^2A^T)$ 高斯分布相乘 若$x\\sim(\\mu_0,\\sigma_0^2)$，$y\\sim(\\mu_1,\\sigma_1^2)$，则$x*y \\sim (A\\mu+b,A\\sigma^2A^T)$ 4 常用数学公式 5 利群与李代数转换 $$ \\begin{aligned} exp(\\phi^{\\wedge}) \u0026amp;=R \\\\[1ex] \\phi \u0026amp;= log(R)^{\\vee} \\\\[1ex] \\phi^{\\wedge} \u0026amp;= log(R) \\end{aligned} $$\n5.1 叉积交换 $$ \\begin{aligned} a \\times b = - b \\times a \\\\ \\partial\\theta^{\\wedge} \\omega = \\omega^{\\wedge} \\partial\\theta \\end{aligned} $$\n5.2 SO(3) 伴随公式 $$ \\phi^{\\wedge}R = R(R^T\\phi)^{\\wedge} $$\n5.3 指数函数常用性质 12445 $$ \\begin{cases} e^{x} = 1 + x + \\cdots + \\dfrac{x^n}{n!} \\\\[8pt] e^{-ax} = e^{-a} + e^{x} \\\\[8pt] e^{a+b} = e^{a}e^{b} \\end{cases} \\quad\\Rightarrow\\quad \\begin{cases} \\exp(x) = 1 + x \\\\[8pt] \\exp(\\theta + \\Delta\\theta) = \\exp(\\theta)\\exp(\\Delta\\theta) \\end{cases} $$### BCH 近似 BCH 公式关联了李群乘法与李代数加法之间的关系，李群（SO(3)）上乘小量等于李代数（so(3)）上加小量（带雅可比矩阵） $$ \\begin{aligned} exp(\\phi^{\\wedge})exp(\\Delta\\phi^{\\wedge}) \\approx exp((\\phi+J_r^{-1}\\Delta\\phi)^{\\wedge})\n\\\\[1ex]\nexp(\\phi+\\Delta\\phi) \\approx exp(\\phi^{\\wedge})exp(J_r\\Delta\\phi^{\\wedge}) \\approx exp(J_l\\Delta\\phi^\\wedge)exp(\\phi^{\\wedge})\n\\\\[1ex]\nLog(R exp(\\Delta \\phi)) \\approx Log(R)+ J_r^{-1}(Log(R))\\Delta\\phi^{\\wedge}\n\\\\[1ex]\nlog(\\prod_{k=1}^{j-1}exp(\\Delta\\phi ))^{\\vee} \\approx \\sum_{k=i}^{j-1}\\Delta\\phi, \\quad \\text{由于 $\\Delta\\phi$ 为小量,所以假定了$J_r=I$} \\end{aligned} $$\n旋转求导 $$ \\begin{cases} \\dot{R} = Rw^{\\wedge}, \\quad \\text{该式也称为泊松方程，w为瞬时角速度}\n\\\\[1ex]\n\\dot{exp(\\delta\\theta^{\\wedge})} = exp(\\delta\\theta^{\\wedge})exp(\\delta\\dot{\\theta}^{\\wedge}) \\end{cases} $$\n","permalink":"https://zhouwuxiong.github.io/posts/slam-%E5%9F%BA%E7%A1%801/","summary":"\u003ch2 id=\"1-常见符号表示\"\u003e1 常见符号表示\u003c/h2\u003e\n\u003ch2 id=\"2-so3上的bch近似公式\"\u003e2  SO(3)上的BCH近似公式\u003c/h2\u003e\n\u003cp\u003eBCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（\u003cstrong\u003e李代数加法 ⇔ 李群乘法\u003c/strong\u003e），其线性近似公式广泛应用于各种函数的线性化。\n在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成：\n$$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$\n反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法：\n$$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge)\n$$\n其中SO(3)的左雅克比矩阵为\n$$\n\\begin{aligned}\n{J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\{J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge}\n\\end{aligned}\n$$\n而SO(3)的右雅克比矩阵为\n$$\n{J}_r({\\phi}) = {J}_l(-{\\phi})\n$$\u003c/p\u003e\n\u003ch2 id=\"3-kfekfeskf\"\u003e3 KF、EKF、ESKF\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eKF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数\u003c/strong\u003e\n\u003ca href=\"https://zhuanlan.zhihu.com/p/39912633\"\u003eSite Unreachable\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵\n\u003cstrong\u003eKF\u003c/strong\u003e\n假设运动方程为:\n$$\nx_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2)\n$$\n由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。\n$$\nx_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T)\n$$\n\u003cstrong\u003eEKF\u003c/strong\u003e\n假设运动方程为:\n$$\nx_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2)\n$$\n其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开：\n$$\nf(x) = f(x_k) + J(x-x_k)\n$$\n所以下一时刻的$x_{k+1}$ 的分布为\n$$\nx_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T)\n$$\n其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。\n\u003cstrong\u003eESKF\u003c/strong\u003e\nESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\u003c/p\u003e","title":"SLAM 基础"},{"content":"1 常见符号表示 2 SO(3)上的BCH近似公式 BCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（李代数加法 ⇔ 李群乘法），其线性近似公式广泛应用于各种函数的线性化。 在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成： $$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$ 反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法： $$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge) $$ 其中SO(3)的左雅克比矩阵为 $$ \\begin{aligned} {J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\{J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge} \\end{aligned} $$ 而SO(3)的右雅克比矩阵为 $$ {J}_r({\\phi}) = {J}_l(-{\\phi}) $$\n3 KF、EKF、ESKF KF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数 Site Unreachable\nKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵 KF 假设运动方程为: $$ x_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。 $$ x_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T) $$ EKF 假设运动方程为: $$ x_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2) $$ 其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开： $$ f(x) = f(x_k) + J(x-x_k) $$ 所以下一时刻的$x_{k+1}$ 的分布为 $$ x_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T) $$ 其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。 ESKF ESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\n高斯分布的线性变换 若$x\\sim(\\mu,\\sigma^2)$，则$Ax+b \\sim (A\\mu+b,A\\sigma^2A^T)$ 高斯分布相乘 若$x\\sim(\\mu_0,\\sigma_0^2)$，$y\\sim(\\mu_1,\\sigma_1^2)$，则$x*y \\sim (A\\mu+b,A\\sigma^2A^T)$ 4 常用数学公式 5 利群与李代数转换 $$ \\begin{aligned} exp(\\phi^{\\wedge}) \u0026amp;=R \\\\[1ex] \\phi \u0026amp;= log(R)^{\\vee} \\\\[1ex] \\phi^{\\wedge} \u0026amp;= log(R) \\end{aligned} $$\n5.1 叉积交换 $$ \\begin{aligned} a \\times b = - b \\times a \\\\ \\partial\\theta^{\\wedge} \\omega = \\omega^{\\wedge} \\partial\\theta \\end{aligned} $$\n5.2 SO(3) 伴随公式 $$ \\phi^{\\wedge}R = R(R^T\\phi)^{\\wedge} $$\n5.3 指数函数常用性质 12445 $$ \\begin{cases} e^{x} = 1 + x + \\cdots + \\dfrac{x^n}{n!} \\\\[8pt] e^{-ax} = e^{-a} + e^{x} \\\\[8pt] e^{a+b} = e^{a}e^{b} \\end{cases} \\quad\\Rightarrow\\quad \\begin{cases} \\exp(x) = 1 + x \\\\[8pt] \\exp(\\theta + \\Delta\\theta) = \\exp(\\theta)\\exp(\\Delta\\theta) \\end{cases} $$### BCH 近似 BCH 公式关联了李群乘法与李代数加法之间的关系，李群（SO(3)）上乘小量等于李代数（so(3)）上加小量（带雅可比矩阵） $$ \\begin{aligned} exp(\\phi^{\\wedge})exp(\\Delta\\phi^{\\wedge}) \\approx exp((\\phi+J_r^{-1}\\Delta\\phi)^{\\wedge})\n\\\\[1ex]\nexp(\\phi+\\Delta\\phi) \\approx exp(\\phi^{\\wedge})exp(J_r\\Delta\\phi^{\\wedge}) \\approx exp(J_l\\Delta\\phi^\\wedge)exp(\\phi^{\\wedge})\n\\\\[1ex]\nLog(R exp(\\Delta \\phi)) \\approx Log(R)+ J_r^{-1}(Log(R))\\Delta\\phi^{\\wedge}\n\\\\[1ex]\nlog(\\prod_{k=1}^{j-1}exp(\\Delta\\phi ))^{\\vee} \\approx \\sum_{k=i}^{j-1}\\Delta\\phi, \\quad \\text{由于 $\\Delta\\phi$ 为小量,所以假定了$J_r=I$} \\end{aligned} $$\n旋转求导 $$ \\begin{cases} \\dot{R} = Rw^{\\wedge}, \\quad \\text{该式也称为泊松方程，w为瞬时角速度}\n\\\\[1ex]\n\\dot{exp(\\delta\\theta^{\\wedge})} = exp(\\delta\\theta^{\\wedge})exp(\\delta\\dot{\\theta}^{\\wedge}) \\end{cases} $$\n","permalink":"https://zhouwuxiong.github.io/posts/test/","summary":"\u003ch2 id=\"1-常见符号表示\"\u003e1 常见符号表示\u003c/h2\u003e\n\u003ch2 id=\"2-so3上的bch近似公式\"\u003e2  SO(3)上的BCH近似公式\u003c/h2\u003e\n\u003cp\u003eBCH公式给出了李代数上的小量加法与李群上小量乘法之间的关系（\u003cstrong\u003e李代数加法 ⇔ 李群乘法\u003c/strong\u003e），其线性近似公式广泛应用于各种函数的线性化。\n在SO(3)中，某个旋转 $R$ 对应的李代数为 $\\phi$，左乘一个微小旋转，记作 $\\Delta{R}$，对应的李代数为 $\\Delta\\phi$，那么在李群上得到的结果就是 $\\Delta RR$，而在李代数上，根据BCH近似，为 $J_l({\\phi})^{-1}\\Delta{\\phi} +{\\phi}$ 合并后可以简单写成：\n$$\\Delta{R}{R} = \\exp(\\Delta{\\phi}^{\\wedge})\\exp({\\phi}^{\\wedge}) = \\exp \\left(({\\phi} + {J}_l({\\phi})^{-1}\\Delta{\\phi})^{\\wedge} \\right)$$\n反过来，如果在李代数上进行加法，让一个 ${\\phi}$加上小量 $\\Delta{\\phi}$，那么可以近似为李群上带左右雅克比矩阵的乘法：\n$$\\exp(({\\phi} + \\Delta{\\phi})^{\\wedge}) = \\exp(({J}_l({\\phi})\\Delta{\\phi})^\\wedge) \\exp({\\phi}^\\wedge)= \\exp({\\phi}^\\wedge) \\exp(({J}_r({\\phi})\\Delta{\\phi})^\\wedge)\n$$\n其中SO(3)的左雅克比矩阵为\n$$\n\\begin{aligned}\n{J}_l(\\theta{a}) \u0026amp;= \\frac{\\sin\\theta}{\\theta}{I} + (1-\\frac{\\sin\\theta}{\\theta}){a}{a}^T+(\\frac{1-\\cos\\theta}{\\theta}){a}^{\\wedge} \\{J}^{-1}_l(\\theta{a}) \u0026amp;= \\frac{\\theta}{2}\\cot\\frac{\\theta}{2}{I} + (1-\\frac{\\theta}{2}\\cot\\frac{\\theta}{2}){a}{a}^T-\\frac{\\theta}{2}{a}^{\\wedge}\n\\end{aligned}\n$$\n而SO(3)的右雅克比矩阵为\n$$\n{J}_r({\\phi}) = {J}_l(-{\\phi})\n$$\u003c/p\u003e\n\u003ch2 id=\"3-kfekfeskf\"\u003e3 KF、EKF、ESKF\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eKF 的状态和观测方程的递推是高斯分布的线性变换，融合结果则是两个高斯分布相乘得到一个新的高斯分布，卡尔曼增益则是系数\u003c/strong\u003e\n\u003ca href=\"https://zhuanlan.zhihu.com/p/39912633\"\u003eSite Unreachable\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eKF、EKF、ESKF 的本质都是对高斯分布的线性变换。他们的区别在于高斯线性变换时的系数不同，KF 的线性系数是常数，EKF的线性系数是雅可比矩阵\n\u003cstrong\u003eKF\u003c/strong\u003e\n假设运动方程为:\n$$\nx_{k+1} = Ax_k + u_k + w_k, w \\sim (\\mu,\\sigma^2)\n$$\n由于该公式为线性变换，所以$x_{K+1}$ 也服从高斯分布。\n$$\nx_{k+1} \\sim (A\\mu + u_k ,A \\sigma^2 A^T)\n$$\n\u003cstrong\u003eEKF\u003c/strong\u003e\n假设运动方程为:\n$$\nx_{k+1} = f(x_k) + u_k + w_k, w \\sim (\\mu,\\sigma^2)\n$$\n其中$f(x)$ 表示非线性变换，将其在$x_k$进行一阶泰勒展开：\n$$\nf(x) = f(x_k) + J(x-x_k)\n$$\n所以下一时刻的$x_{k+1}$ 的分布为\n$$\nx_{k+1} \\sim (J \\mu + u_k, J \\sigma^2 J^T)\n$$\n其与KF 的区别在与 A 是常量，而 J 是与线性化点相关的变量。\n\u003cstrong\u003eESKF\u003c/strong\u003e\nESKF 与 EKF 类似，只是 EKF 是对整个运动方程进行高斯过程，而 ESKF 只对噪声进行高斯过程，对于测量值（名义变量）则进行直接的递推。最终的结果由测量值的递推和噪声的预测值相加得到。\u003c/p\u003e","title":"SLAM 基础"},{"content":"流程 12414112312324125456787914112233334455668899 obsidian 安装 Enveloppe 1 hugo (静态网站模板生称工具) sudo snap install hugo # disable automatic updates sudo snap refresh --hold hugo hugo new site quickstart hugo version 2 obsidian 安装 Enveloppe link test\n3 Enveloppe 配置 复制 json 文件导入 obsidian-github-publisher-hugo/settings.json at main · miaogaolin/obsidian-github-publisher-hugo · GitHub\n3.1 Enveloppe 配置github fork 网站模板 获取 github token 3.2 目录配置 4 vecel 部署 ","permalink":"https://zhouwuxiong.github.io/posts/obsidian-blog-publish/","summary":"\u003ch1 id=\"流程-12414112312324125456787914112233334455668899\"\u003e流程 12414112312324125456787914112233334455668899\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eobsidian 安装  \u003ccode\u003eEnveloppe\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"1-hugo-静态网站模板生称工具\"\u003e1 hugo (静态网站模板生称工具)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo snap install hugo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# disable automatic updates\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo snap refresh --hold hugo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo new site quickstart \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo version\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2-obsidian-安装--enveloppe\"\u003e2 obsidian 安装  Enveloppe\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"link%20test.md\"\u003elink test\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"3-enveloppe-配置\"\u003e3 Enveloppe 配置\u003c/h2\u003e\n\u003cp\u003e复制 json 文件导入\n\u003ca href=\"https://github.com/miaogaolin/obsidian-github-publisher-hugo/blob/main/settings.json\"\u003eobsidian-github-publisher-hugo/settings.json at main · miaogaolin/obsidian-github-publisher-hugo · GitHub\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"31-enveloppe-配置github\"\u003e3.1 Enveloppe 配置github\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"2-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/2-obsidian%20blog%20publish.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003efork 网站模板\u003c/li\u003e\n\u003cli\u003e获取 github token\n\u003cimg alt=\"1-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/1-obsidian%20blog%20publish.png\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"32-目录配置\"\u003e3.2 目录配置\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"3-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/3-obsidian%20blog%20publish.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"4-vecel-部署\"\u003e4 vecel 部署\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"4-obsidian blog publish.png\" loading=\"lazy\" src=\"../../images/4-obsidian%20blog%20publish.png\"\u003e\u003c/p\u003e","title":""}]